 network working group ed belove harvard request for comments dave black harvard bob flegel utah lamar g farquar utah june third level protocol logger protocol general description in our view of the world each host has a set of four programs to allow a user teletype to communicate with a foreign monitor the exact implementation of these programs is highly installation dependent thus all explanations are meant to describe functional characteristics rather than design the four programs come in two male female pairs a user employs a send logger at his site to communicate with receive logger at the appropriate foreign site in order to establish a full duplex link between the user s teletype and the foreign machine s monitor this puts him in the equivalent of a pre logged in state at the other machine after the link has been established the two loggers drop out of the picture and the user is left talking to a sender in his machine whose main function is to take input from the user s teletype and send it down the link that was established by the loggers to the receiver in the foreign host which passes it along to its monitor making it look like input from a local teletype replies from the foreign monitor are given by it to the receiver which transmits them back along the link to the sender which outputs them on the user s teletype the sender and receiver in each machine must either exist in multiple copies one for each network user or there must be a single copy which can handle all of the network users the loggers however need be able to handle only one user at a time since their task is quickly accomplished leaving them free to satisfy other requests however there should be some method of queuing requests that can not be satisfied immediately a less satisfactory alternative would be to give a busy message to any user who tries to use the logger while it is busy this of course does not preclude the possibility of an installation having a re entrant logger or of having multiple copies of the logger the receive logger should be user zero in every machine and should always be listening to socket zero this same thing can be accomplished by having the ncp intercept all messages to user zero socket zero and send them to the receive logger but it is simpler and cleaner to have page the logger actually be user zero and have the ncp handle its messages the same as everyone else s when the send logger is called it pulls a pair of unused sockets n and n from a pool of free sockets and connect from n to user socket in the desired foreign host this activates the receive logger which accepts the connection if it has an available slot for the foreign teletype he then immediately closes down this connection to allow links from other sources to be initiated if on the other hand there is no room for the foreign teletype or if for some other reason the receive logger does not wish to connect the attempted link to socket zero is refused this notifies the send logger that he cannot log on the foreign host and it then notifies the user of this fact there is no guarantee however that the close was actually sent by the foreign logger it could have been sent by the ncp if for example the pending call queue for the socket was overloaded if the link to socket zero has been accepted thus indicating that the receive logger can accommodate the request after closing that link the receive logger picks an available pair of sockets m and m from its pool and connects from m to n it found the identity of n when its listen was answered by the link with n the send logger has meanwhile listened to socket n and now accepts the link and connects from n to m the receive logger has been listening to this socket and accepts the attempted link at this point there is a full duplex connection between the two loggers they then activate the sender and receiver which handle all other communication between the user and the foreign monitor the senders and receivers can be part of the loggers or can be called by them etc when the user is finished and escapes back to his monitor it is up to the sender to close down the links on the receiving end it would be highly desirable for the ncp to notify the receiver of this fact so it could log the user off if he had failed to do that himself and could free any resources that he had been using a more formal outline of the proposed protocol described in the scenario above follows page stable state receive logger at foreign host listening to user socket local user calls send logger send logger calls connect port n send logger calls listen port foreign logger s listen is answered and he is told local user number host and n foreign logger looks for available sockets m and m if they exist and it is able to establish connection it accepts and then immediately closes the link foreign logger calls connect port m foreign logger calls listen port send logger has listened to n and accepts link then calls connect port n receive logger which is listening on m accepts link loggers activate appropriate handlers when the user is finished sender closes down both links this basic method of establishing a full duplex connection should be standard throughout the network the particular way each installation handles the implementation of the sender receiver and the two loggers is of no consequence to the network and is highly machine dependent even the fact of needing a sender and receiver is machine dependent in that some members of the network might be able to handle their functions in other ways however some conventions must be established regarding communication between the sender and receiver or their equivalents network standard code in order to facilitate use of the network we propose the convention that all teletype to foreign monitor communication be done using character usascii this is the code used by the imp s and is in the appendix to the imp operating manual it makes sense to require machines to make only one conversion to a standard code than to have to make conversions to every code on the net page in addition since most of the network machines use ascii as their internal character code it will be no trouble for them even those machines that use a different code must translate to and from ascii in order to communicate with local teletypes extending this translation to the network should cause very little trouble we envision this translation as taking place in the sender and receiver but again that is implementation dependent if ascii is adopted as a standard we would suggest that all non ascii machines create a monitor to the machine s internal code this would make the complete character set available to those who wished to use it and were willing to write a simple conversion routine for the local machine in this way those users who wanted to could use any machine on the net from their teletype without requiring their machines to have records of all the network codes and yet could use the full power of the foreign machine if they wanted again this standard applies only for teletype to foreign monitor communication break characters a standard way of handling the break character has to be established for the network and be included in the protocol problems with the break character arise in several contexts first there are two distinct purposes served by the break character one is as a panic button this says i do not care what is happening stop and get me out to monitor level now this command is executed immediately upon receipt and is most commonly used to get out of a program that one does not want to be in e g one that is in an infinite loop etc the other purpose that is served is that of an exit from a subsystem or on a machine with a forking structure as a method to get back to the next higher level fork this second purpose is not an immediate one in that the user wants the system to finish all that he has told it to do before exiting we assume that there does not exist in every system a way of performing each of these functions or a clear cut distinction between the calling and operation of the two furthermore there are subtle distinctions as to how each system treats the commands the panic button function can easily be performed by the proposed control command this function must be accomplished by using a control command since a program can enter a state where it is accepting no input hence the program cannot be aborted by sending it a message down the teletype link there is no reason to worry about the race condition caused by sending this command down the control link since its page whole purpose is to force the machine to disregard everything else the user has sent in our implementation of this we would ask the user to specify to the logger a seldom used character that he wants to be his foreign panic button then it would be a simple task for the sender to map this character into an command which the foreign machine must interpret properly this scheme would work well for most machines but some may lend themselves to different ways of generating the the other problem that presents itself is what to do if the foreign machine s exit character is the same as the local machine s the problem is that while a user is talking to a foreign machine he would want to be in a transparent mode where everything he types is sent directly to the other machine the way he would get himself out of this mode is to type either his machine s exit character or its panic button thus if the foreign machine has the same one there would be no way to send it the way out of this is the same as above merely a mapping of another seldom used character into the foreign machine s exit character this type of mapping can be carried as far as each installation deems necessary giving the user complete control over translation is helpful in that it allows him to user characters that his teletype cannot generate command message formats each site should establish its now conventions about when to send a monitor command string and in what size chunks when performing a routine operation one might want to send several command lines as a single message if working with the monitor as usual a reasonable break point might be at every carriage return when using a highly interactive language such as qed one might decide character by character transmission was a necessity we feel that each user should have the choice between these three methods and possible more furthermore the user should be able to change between each mode at will the differences in syntax of the send message commands mentioned above should be noted for the first a special send message command character must be defined and it should not be sent along with the message for the second the carriage return acts dually as the send message command and as a command delimiter therefore it must be sent with the message finally the case of character by character transmission with its implicit send command should pose no significant problems page the preceding discussion is meant to imply also that the receiver must be able to buffer up each of the above types of transmission into a form acceptable to its own monitor interface in addition all echoing should be done in the local host with the foreign machine suppressing its echoes if it can we would like to thank carl ellison of utah for his valuable suggestions and criticisms of this work and jim curry of utah for his encouragement and support of the effort this rfc was put into machine readable form for entry into the online rfc archives by jon ribbens page 