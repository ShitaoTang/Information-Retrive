 network working group bob bressler request for comments mit dynamic modeling nic dan murphy category c experimentation bbn tenex obsoletes dave walden updates none bbn imp may a proposed experiment with a message switching protocol contents introduction some background references msp specification issue message header examples telnet the information operator unique port numbers flow chart msp variations appendix introduction a message switching protocol msp is a system whose function is to switch messages among its ports for example there is an implementation of an msp in each interface message processor we believe that the effective utilization of communications networks by computer operating systems will require a better understanding of msps in particular we feel that network control programs ncps as they have been implemented on the arpa computer network arpanet do not adequately emphasize the communications aspects of networking i e they reflect a certain reluctance on the part of systems people to move away from what we term the stream orientation we propose as an aside the network development using the current ncps to rethink the design of ncp level software beginning with a consideration of msps the thrust of this note is to sketch how one would organize the lowest level host host protocol in the arpanet around msps and how this organization would affect the implementation of host software bressler et al experimentation page rfc message switching protocol experiment may some background over the past several weeks there has been considerable informal discussion about the possibility of implementing on an experimental basis in several of the arpa network host computers ncps which follow a protocol based on the concept of message switching rather than the concept of line switching see the parenthetical sentence in the first paragraph of page of nic document host host protocol for the arpa network party to this discussion have been bob bressler mit dynamic modeling steve crocker arpa will crowther bbn imp tom knight mit ai alex mckenzie bbn imp bob metcalfe mit dynamic modeling dan murphy bbn tenex jon postel ucla nmc and dave walden bbn imp several interesting points and conclusions have been made during this discussion bressler has implemented a message switched interprocess communication system for the dynamic modeling pdp and has extended it so it could be used for interprocess communication between processes in the dynamic modeling pdp and the ai pdp he reports that it is something like an order of magnitude smaller than his ncp murphy has noted that a host host protocol based on message switching could be implemented experimentally and run in parallel with the real host host protocol using some of the links set aside for experimentation further murphy has noted that if this experimental message switching protocol were implemented in tenex a number of tenex sites could easily participate in the experiment it is the consensus of the discussants that bressler should take a crack at specifying a message switching protocol and that if this specification looked relatively easy to implement a serious attempt should be made by murphy and bressler to find the resources to implement the experimental protocol on the two bbn tenex and the mit dynamic modeling and ai machines msp was chosen as the acronym for message switching protocol and links were reserved for use in an msp experiment this note fulfills any obligation bressler may have incurred to produce an msp specification bressler et al experimentation page rfc message switching protocol experiment may we solicit comments and suggestions from the network working group with regard to this experiment however although we will very much appreciate comments and suggestions because this is a limited experiment and not an attempt to specify a protocol to supersede the present host host protocol for the arpa network we may arbitrarily reject suggestions references familiarly with the following references will be helpful to the reading of the rest of this note nic document host host protocol for the arpa network nic document on the telnet protocol nic document official initial connection protocol document a system of interprocess communication in a resource sharing computer network cacm april reference is a revision of rfc we strongly suggest the reader be familiar with reference before he attempts to read the present rfc a reprint of reference is attached as an appendix bressler et al experimentation page rfc message switching protocol experiment may msp specification our msp is essentially a generalization of the interprocess communication system outlined in section of the fourth reference henceforth if we are required to mention the interprocess communication system presented in section of reference we shall call it the ipc for two processes to communicate using the msp the process desiring to send must in some sense execute a send and the process desiring to receive must in some sense execute a receive the send and receive in effect rendezvous somewhere and transmission is allowed to take place with the receive are specified among other things a from to port id a to port id and a rendezvous host with send are specified a from port id a to port id a rendezvous host and possibly some data to be transmitted using send and receive sending a message from a sender process to a receiver process takes place as follows the sender process executes a send which causes an out message plus the specified data to be transmitted to the host specified as the rendezvous host in the send concurrently although not necessarily simultaneously the receiver process executes a receive which causes an in message to be sent to the host specified as the rendezvous host in the receive at the rendezvous host out messages and in messages are entered in a table called the rendezvous table when an out message and an in message are detected with matching to port id from port id and rendezvous host three things are done the out message plus the data is forwarded to the host which was the source of the in message the in message is forwarded to the host which was the source of the out message and the in message and out message plus the data are deleted from the rendezvous table in the rendezvous host the process is greatly simplified if the rendezvous host is also either the send host or receive host specific algorithms enumerating these sequences appear later in this note to clarify the basic concepts let us look at a case involving three hosts to which we shall give the names snd rcv and rndz at host snd process s is doing a send and at host rcv process r is doing a receive both specify rendezvous at host rndz bressler et al experimentation page rfc message switching protocol experiment may host snd host rcv process s host rndz process data r process s now executes a send with from port id s to port id r and rendezvous host rndz host snd then creates a table entry in its rendezvous table host snd msp rendezvous table process s send from s to r rend rndz data host snd now sends an out message with s s data to host rndz host snd host rndz msp out data msp rendezvous table from s to r data buffer concurrently process r at host rcv executes a receive with from port id s to port id r and rendezvous host rndz as above host rcv creates a table entry in its rendezvous table and sends an in message to host rndz see following figure bressler et al experimentation page rfc message switching protocol experiment may don t panic now about buffering in an intermediate host the time to panic is afer you ve read and understood the rest of our arguments host rndz host rcv msp msp table table in receive from s to r v rend rndz buffer process r host rndz now notices that the out from host snd and the in from r at rcv match one another and thus host rndz takes three actions sends an in to host snd from port id s to port id r rendezvous host rndz sends an out and the buffered data to host rcv from port id s to port id r rendezvous host rndz clears the entry from its table host snd host rcv table table in out table data s r host rndz host rcv gets the out and data and finds the matching entry in its table it gives the data to process r and clears the entry from its table host snd gets an in which matches an entry in his table and clears that entry this message serves as a combined acknowledgement and go ahead which can be passed along to process s the transmission is now complete bressler et al experimentation page rfc message switching protocol experiment may by both one or neither of the sender and receiver processes specifying a remote rendezvous host four important different kinds of transmissions can be made to take place these are illustrated in the following four figures in the figures crossed or parallel dotted lines are used to indicate rendezvous the site of the crossed rendezvous is the important difference between types of transmission illustrated in figures circles indicate processes rectangles are rendezvous tables the figures also show in and out messages being passed into the processes the parentheses are used to indicate that the in and out are only conceptually passed into the processes what actually happens is implementation dependent the process might be awakened and be given no further information if it blocked when issuing the send or receive the process might be interrupted and passed some information such as the to port id from the in or the from port id of the out the process might actually be passed the complete in or out message send receive in out data host k a rendezvous at the sender s host send in receive in out data out data host k network host l a rendezvous at the sender s host bressler et al experimentation page rfc message switching protocol experiment may send out data receive in in out data host k network host l a rendezvous at the receiver s host send out data in receive in in out data out data host k net host net host l m a rendezvous at an intermediate host issues timeouts the issue of timeouts is a very sticky one a coherent system of timeouts simplifies everything and does away with races however many hosts are unwilling or unable to use timeouts especially timeouts whose duration is specified without these timeouts there is probably a need for a negative acknowledgment which goes back to the source of an in or out when one is timed out however this now leads to races a negative acknowledgment which we will refer to as a flush message could be employed by a host to mean bressler et al experimentation page rfc message switching protocol experiment may i have no room in my table i have no more available buffer space or i no longer wish to retain the table entry buffer in general we believe that a host should be allowed to throw away an in or out data whenever it is no longer convenient for the host to hold the messages this can be immediately on the arrival of a message for instance if the host does not want to buffer traffic for which it does not have a user buffer in lieu of timeouts any time a process issues a send or receive it can take it back by issuing the matching receive or send blocking the process after a send or receive this is a question which is left implementation dependent in general we do not think it is a good idea to block the process after a send since it may want to do another to another port or even do a receive in fact we see nothing inherently wrong with a process doing two or more sends to the same port as long as the communicating processes know what they are doing of course some communicating processes will prohibit several simultaneous messages being in transit between the same ports for instance the telnets may well prohibit this however for reasons of increasing bandwidth etc two processes may well want several simultaneous messages in this case we think it is up to the processes to worry about the sequencing of messages however we refer users desiring their processes to take a care of message sequencing to the method used in the imp very distant host interface which is documented in appendix f of bbn report message buffering a few points are worth mentioning with regard to message buffering first most outs will probably be accompanied by data therefore in general since the receiver process may be swapped out the receiver host monitor must be prepared to buffer some data somewhere to minimize the amount of buffering needed the monitor could refuse further traffic from the imp until the earlier traffic from the imp has been written on a disk or drum or the monitor could have a small number of buffers in the monitor area of memory which it fills as traffic comes from the imp and which are swapped with buffers claimed earlier by the receiver processes as the receiver processes are swapped in note that the buffers may be less than the maximum subnet message size in length if the receives never specify a longer message length of course this can be enforced finally note that the message size bressler et al experimentation page rfc message switching protocol experiment may receive port id etc are available in the first bits which come in from the imp it might be useful to read this before deciding into which buffer to read the rest of the message positive acknowledgments built into the system is a certain form of acknowledgment the information is always available as to when the receiving process has done a receive the sending host is assured of receiving an in when the receive call is issued further forms of acknowledgment and validation can be implemented at the first user level and advanced protocols will probably develop a library of such routines message header the following section deals with the specific format of host to host messages and algorithms describing the proper response to a given message each message begins with a bit header containing the following fields host to imp leader bits as specified in bbn reports to port id i e the id of the port receiving the message bits msg type bits in out flush etc from port id i e id or the port sending the message bits initiating host s table position bits see below host sourcing this message bits see below rendezvous host bits bit count of data bits the header format has been arranged so that no data item will cross a word boundary on machines with and bit words except where the size of the item is greater than the word size the actual arrangement of bytes within words is shown in the following figures for these three word sizes for the benefit of bit hosts bytes and numbering from are unused the and byte items do not bressler et al experimentation page rfc message switching protocol experiment may cross word boundaries except for the port id s on the bit machines this attention to packing and unpacking ease was given both for general convenience and in particular because hosts may wish to examine the header at interrupt level to determine where the rest of the message should go host imp destination flags link to port id message type from port id table position source rendezvous host host bit count data bit host format unused bits bressler et al experimentation page rfc message switching protocol experiment may host imp foreign link flags host to port id message type from port id table position source rendezvous bit count host host data bit host format host imp foreign link flags host to port id message from port id type table source rendezvous position host host bit count data bit host format bressler et al experimentation page rfc message switching protocol experiment may the fields within the host imp leader are already familiar to ncp programmers however two points about these fields are worth mentioning first the destination field originally contains the number of the rendezvous host after rendezvous at a intermediate site the destination field contains the source of the message rendezvous with second the link field for the msp experiment can only contain link number we have not taken the time to figure out a sensible allocation of these four links among all the messages which might be sent using the msp one alternative is to cycle over the links to increase the bandwidth of the pipe between any two hosts for the time being until further consideration is given to this issue we suggest each host at a site using one unique link for all its communication the message types we have to represent in the message type field are few now we suggest message type for send or out messages and message for receive or in messages message type is the flush message if flush is used the rendezvous host field needs no comment except that the field is unnecessary after the rendezvous has taken place and could then be used for something else the bit count is a count of data bits in an out message or the size of the input buffer not including the header in an in message thus the sender process can tell from the in message bit count when it receives the in message how much of the data in the out message was accepted by the receiver process and can use this knowledge to retransmit the remainder of the message if so desired after the rendezvous we recommend that all of the data in the message be sent on the source of the in message even if the out bit count was greater than the in bit count thus at the receiver host the monitor has the option if it wants to take it of discarding the message for being too long sending the number of bits the receiver process has done an in for into the receiver process and discarding the rest or queuing the rest of the bits and somehow notify the receiver process that there are more bits which the receiver process can ask for the to and from port id fields are bit numbers this size was chosen to help the tips the first eight bits of a port id should be the number of the host at which this port id was created note well that this is not necessarily the host at which the port is being used this is necessary since rendezvous take place at intermediate sites and because ports may move from site to site we suggest that all port ids with the first eight bits all zero be reserved for network wide use in particular a port id with all bits zero will be used to mean any this gives us the options of bressler et al experimentation page rfc message switching protocol experiment may receive from any to specific receive from specific to specific send from specific to any and send from specific to specific examples of the use of these options will be given below the other options receive to any and send from any we feel are kind of useless but would not prohibit them we believe that in the absence of explicit specification of rendezvous host the use of an any port id in the user s system call should affect the default rendezvous site as follows receive from any rendezvous in receiver receive from specific rendezvous in sender send to any rendezvous in sender send to specific rendezvous in sender the less significant bits of the id can be used however a host wants to for instance eight bits might be used as a process id and eight bits might be used as a channel specification within the specified process we suggest that each host reserve the port ids with the middle eight bits all zero for special uses as well known ports the table position field is included to help prevent costly table searches at interrupt level hosts sending ins and outs put in the table position field the rendezvous table position of the send or receive associated with the in or out at an intermediate host rendezvous the table position fields in the matching in and out are swapped so that when the messages arrive at the opposite end the matching send and receive can be found quickly the msp must do the swap at the rendezvous but of course the msps need not fill in the table position field when first transmitting an in or out in which case the information arriving in an in or out will be meaningless the general algorithm then is to check the table position as specified in this field and if that fails search the whole table the source field is filled in ins and outs by the msp which originally sends these messages at the rendezvous the source of each message is preserved in the message being forwarded to the final host when an in or out arrives at a process the process can use bressler et al experimentation page rfc message switching protocol experiment may the source information to update its understanding of the rendezvous host e g when the destination host and rendezvous host are different examples the typical example we envision communication normally taking place using specifications to and from ports and rendezvous at the sender for instance the tip would probably send to other hosts using this method and would certainly receive from other host until the tip asks for it in this normal method a monitor could even look at the bit count in the arriving in message use that as an allocation and then simulate an out message of the exact correct length the logging example consider an example of send to specific and receive from any with the rendezvous at the receiver this method might be used by some logging receiver process with a well known to port for instance a measurements program to which statistics are sent from many processes throughout the net the program library example suppose within a given time sharing system there is a particular library routine which is available for use by any process in the network the library process has a receive from any always pending at a well known port eventually some process sends a message to the library process well known port this message includes the data to be processed a port to use for sending the answer and the money the library process takes some of the money and sends it to the well known port of the accounting process which itself has a receive from any pending the library process then processes the data and sends the answer back to the process which requested the service using a send to specific message which rendezvous at the destination where there is already a receive from specific pending of course in this message besides the answer any change the requesting process has coming is returned a comment as can be seen from our examples we think rendezvousing at an intermediate host will seldom be done as the chief benefit of this comes when it is desirable to move a port see reference for a discussion of this we would like to see all hosts provide some bressler et al experimentation page rfc message switching protocol experiment may meager amount of buffering for this purpose but would not require it it shouldn t be too painful to provide a little of this kind of buffering especially since a host can throw away any message it can t handle this page will be replaced with a better description of telnet under msp in a few days dcw telnet let us postulate a pair of telnet programs that maintain two bidirectional communication paths one for data and one for control let us also assume for convenience that the port ids are as follows if the write control id is n then read control id n write data n read data n the initial state is the server telnet sitting with a read from any pending the user telnet now issues a send to specific with the data field containing the port id of the server s write control id this message is sent from the user telnet s write control id thus all port ids are specified by the user telnet so if desired he need only remember one number and derive the rest uniqueness is preserved since the port ids supplied by the user telnet contain his host id and other information making the id unique to him now that these communication paths are established the two processes can exchange data and control information according to established telnet protocols the information operator the message switching protocol itself impose no fixed requirements on the use of the port id s and the problem of process identification is somewhat separated from the means used to effect communication it is however very much a part of the overall issue of interprocess communication and so we here specify a facility for handling process identification the information operator bressler et al experimentation page rfc message switching protocol experiment may one goal in a process identification scheme is to provide a means by which processes can select their own identifiers which can be guaranteed unique and can contain information meaningful to the user problems of efficiency prevent making the port id s themselves large enough to accomplish this aim efficiency questions aside it would appear to be ideal to allow processes to use character strings of arbitrary length to identify themselves uniqueness can then be easily ensured if for example users follow the convention of including their names in the process identification string further the remainder of the name can be chosen to have some meaning related to its use with obvious advantages and convenience for users one solution is to establish a convention whereby the symbolic identifiers are used only during some initial phase of communication and not in every message that is processes identify each other initially using symbolic identifiers but exchange local port identifiers at the same time which are used for all ensuing messages the means of providing this facility is to establish a process at each of a number of hosts e g all server hosts called the information operator the function of this process is to associate symbolic identification strings and port id s a process can identify itself and or a foreign process to the information operator and may request the port id of the foreign process the symbolic identification strings are chosen by the processes and are long enough to contain meaningful information e g logger murphy testprog communication with the information operator whether by local or remote processes is via the regular msp functions the information operator will always have a receive any outstanding on a well known port this could in general be the only well known port in existence a message received on this port contains the following parameters string identifying the foreign process with which communication is desired string identifying the calling process calling process port number a delay specification bressler et al experimentation page rfc message switching protocol experiment may the format of these parameters is shown in fig in some cases one or more of the arguments would be null following receipt of a message the information operator will in some cases do a send specific to the calling process port number providing the desired information or notice of failure the following two cases would appear to cover all functions of the information operator they correspond to the send receive specific any cases of the msp two processes each knowing the specific identify of the other wish to communicate each does a send specific to the information operator giving parameters the default delay spec in this case being wait when the information operator receives the second of these and notes that a match exists it sends to each process the port id of the other process and deletes both strings and both port id s from its tables the two processes which have each done a receive specific in anticipation of the foreign port number can then communicate using just the port numbers and basic msp functions a process is set up to provide some sort of general service or information and its name and protocol advertised this process intends to maintain an outstanding send or receive any for the first and perhaps only message transaction e g the library process discussed earlier most such processes would be receivers initially but there might be a few cases where a send could be left outstanding and a forcing process could come along and pick up the information in either case the service process will do send specific to the information operator giving the local symbolic id and local port id the foreign symbolic id would be null and the default delay spec is no wait that is info local id local port the information operator will enter this information in its tables but return nothing to the caller the caller would proceed to do its send receive any to wait for business when another process wishes to use the advertised service it asks the logger for the port id of the service process i e info service id local port the local symbolic id need not be specified and the default delay spec is no wait the information operator would send the port id of the service process to the local port of the caller and retain the table entry for future callers only the service process bressler et al experimentation page rfc message switching protocol experiment may could request the entry be deleted if the service id was unknown to the information operator at the time of this call it would immediately return a failure indication i e zero communicating processes would normally use the information operator local to one or the other and like the rendezvous host in the msp this would be agreed upon in advance service processes would normally use the information operator at their local site and correspondingly user processes would call the information operator at the site where the service process was expected to be available there is no restriction on using an information operator at some other site of course and some small and or lazy servers could use a different host for their service process id s it presents no problem for two or more information operators to have entries for the same service process and in fact this may be very desirable for special types of service processes which exist only one place on the net and may move around from time to time processes would specify their own local port numbers and each system would have to provide some way to help user processes do this in tenex for example one would probably use the job number concatenated with another number assigned within the job the information operator cannot supply port numbers because it will be running on a different host than one or both of the communicants and cannot know what is a unique number for that host in some cases processes would ask the unique number process described below for their local port id and would make it known via the information operator in actual practice a few exceptions would be made to the rule that the only well known port in the world is the information operator such exceptions would be processes common to many hosts e g logger or those in particularly frequent use in such cases the unique port numbers would be assigned by administrative fiat and recorded and published to all users the symbolic identification strings are specified to be from to an arbitrary maximum ascii characters terminated by a null byte of all zeroes the characters will be bit ascii in bit bytes with the high order bit set to zero a null string first byte is null is used where no argument is required bressler et al experimentation page rfc message switching protocol experiment may format of information operator messages to information operator a stream of bit bytes char n null char n null port number delay spec parameter parameter parameter parameter parameters given string identifying the foreign process with which communication is desired to characters or null string identifying the calling process to characters or null calling process port number delay specification default wait for match don t wait for match from information operator bit bytes byte port number bits of requested foreign port if successful if unsuccessful unique port numbers the existence of unique port numbers is essential to the operation of the msp for instance when two communicating processes specify message rendezvous at an intermediate site the processes must be able to specify to and from ports which are not being used by other processes which have specified message rendezvous at the same site or else messages may be delivered to incorrect destinations we have alluded to a method of providing unique port numbers earlier in this note this method is to partition the bit port number space into disjointed segments and give one segment to each host in the network bressler et al experimentation page rfc message switching protocol experiment may to distribute when it is called upon to create a unique port id thus each bit host number will consist of two major parts the first bits will be the number of the host creating the port id and the next bits can be used in any manner the creating host desires this gives each host port numbers to distribute and each host will have the burden of distributing its segment of the port number space in a unique manner we recommend the convention that the port numbers with the middle bits equal to zero be reserved for well known ports in the creating host s system we already recommend in an earlier section that port numbers with the first bits equal to zero be reserved for network wide use and in particular the port number with all bits equal to zero be used to mean any since each host only has port numbers to distribute in general port numbers will not be able to be held and used by processes for long periods of time e g weeks and months more typically hosts will probably implicitly take back all port numbers the host has distributed each time the host s system goes down and will redistribute the port numbers as required when the system comes back up in other words port numbers will not in general remain unique over the going down of the creating hosts of course a given host may see to give the same port numbers to a number of standard processes such as the fortran compiler each time it comes up port numbers registered with an information operator will frequently remain constant over system ups and downs in spite of the fact that each host will probably not in general be able to distribute port numbers to arbitrary user processes which ca be guaranteed to remain unique over a long period of time there will still be demand for provision of long term unique port numbers to some the procedure of going through the information operator smacks much too much of making a connection these people will insist that for a variety of reasons their processes be allowed to communicate via ports whose identifiers remain constant for long periods of time therefore it would be nice if at one or two places in the network a long term unique number service was provided we ll call a process providing this service the unique number process the unique number process would have assigned to it one segment of the unique port number space all those port numbers for instance with the first bits equal to this process would have a send to any pending from a well known port with local rendezvous specified when any process wanted a unique number which it could depend on not to be used for all time or until the number is given back it would send a receive from specific specifying the well known port of the unique number process and rendezvous at the unique number process host the unique number process pending send to any would contain a unique number also the unique number process would have a receive from bressler et al experimentation page rfc message switching protocol experiment may any always pending at another well known port with local rendezvous specified at this port the unique number process would receive unique numbers which processes are giving back the unique number process would maintain a bit table bits long indicating the state of each of its unique numbers free or in use in some long term storage medium such as in the file system the unique number process might also maintain some information about each process to which it gives a unique number so that when the supply of unique number gets depleted processes can be asked to return them it has already been mentioned that some of the process id s registered along with their symbolic names at the information operator might be long term unique numbers gotten from the unique number process it should also be mentioned that there would seem to be no reason other than scarcity of storage space that in addition to the port number through which primary access is gained to a process and which was called the process id in the previous section arbitrary port numbers along with their symbolic identified could not be registered with an information operator for instance rather than registering the name bbn fortran and a single port number one could perhaps register the port numbers whose symbolic identifiers were bbn fortran control teletype bbn fortran input file bbn fortran listing file and bbn fortran binary output file this is perhaps at odds with standard practice within operating systems but is consistent with the philosophy of reference that communication is done with ports and not processes let us now address an issue which has been ignored up to now and which was only alluded to in reference the issue of port protection we have not given this matter a great deal of thought however one mechanism for port protection seems quite straightforward the heart of this mechanism is a process at each host which we shall call alliteratively the port protection process ppp the ppp maintains a list of all processes which exist at the host and for each process the numbers of all ports which the process has legally obtained every time a process does a send or receive the monitor checks with the ppp to see if the process has specified port numbers it has the right to use i e those legally obtained the ppp has some receives always pending at well known ports when one process wants to pass a port to some other process the first process sends a message to the ppp specifying the number of the port to be sent the host number at which the second process resides a port at which the second process is expecting to receive the port etc the ppp looks up in its tables whether the first process has the port it wants to send if it does it sends a message to the ppp at the destination site the message contains the number of the port to be transferred and the receive port for the destination process the destination ppp checks in its table whether the process has the bressler et al experimentation page rfc message switching protocol experiment may receive port and if so passes the new port to the process and updates its tables to indicate the process now possesses the new port the messages to a ppp will optionally be able to specify that a copy of a port be sent a port be deleted etc the ppps would probably have some built in legal ports for each process particularly the port s processes used to communicate with the ppp the exact specification requires development but that should not be hard see and in reference the main difficulty we see is efficient checking of the ppp s tables by the monitor for every receive or send without entirely supplanting the monitor s current protection system flow chart the following section describes a flow chart for most of the msp a distinction is made between calls made by local processes called send and receive and messages coming in over the net called in and out an additional distinction is made between calls or messages with a local rendezvous and those with a foreign rendezvous host since the code is quite similar the distinction need not be made but will be included for the sake of clarity it is assumed that the msp has table provisions for the following items source of message rendezvous host from port id to port id table position type of message data size and location data about the user process user does a send or receive a rendezvous is at a foreign host store the appropriate table data send a message to the rendezvous host a send out data b receive in b rendezvous is local look for entry in table bressler et al experimentation page rfc message switching protocol experiment may entry not found create entry with appropriate data a matching entry exists in table a receive give user the data b send a message to the other host as specified by the source field of the original msg send out data receive in c alert user to the fact that transaction is complete d clear table entry an in is received over the net search table for matching entry a no matching entry create an entry with appropriate data b a match exists entry was cause by a local send a send out data to source of in b inform user of transaction c clear table entry entry was caused by an out received over net acting as third host a send in to site that created table entry b send out data previously buffered to site sending the in c clear table entry an out data is received over the net search table for matching entry a no match is found buffer data create appropriate table information bressler et al experimentation page rfc message switching protocol experiment may b a match is found table entry was caused by locally executed receive a give data to the user and alert him to its existence b send a matching in to the source of the out c remove entry from table table entry was caused by the receipt of an in over the net thus we are acting as a third party host a send the out data to the host stored in the table b send an in to the host from which the out had just arrived msp variations it may of interest to the reader to know of some of the other msps we have considered while arriving at the present one the simplest we considered is an msp based on all rendezvous being done at the destination host the sender process sends an out message plus the data to the destination host the receiver process does an in which stays at the receivers host the out and receive rendezvous and the data is passed to the receiver process the transmission is now complete except in some variations of this msp an acknowledgement is sent to the sender process this msp has couple of disadvantages in the simplest formulation the receive had to be waiting when the out data arrived otherwise the out data were thrown away this puts too tight a constraint on the timing of the send and receive especially since the sender and receiver processes can be a continent apart however if the in is allowed to arrive first and must be held until matched by a receive the monitor must buffer an indeterminate amount of data in all cases including the normal one further basing everything on rendezvous at the destination makes the process of moving a port difficult the next simplest msp we considered was the ipc of reference this works just the opposite of the above described msp in that it is based on almost all rendezvous being done at the source host with two special messages to handle the relatively uncommon cases when a rendezvous must be done at the destination or an intermediate host this system its advantages and disadvantages is discussed at very great length in the reference bressler et al experimentation page rfc message switching protocol experiment may a third variation on the msp suggested by crowther is the same as the present msp in that the out and in rendezvous at a process specified rendezvous host and the out is sent to the source of the in and the in to the source of the out but the data is not sent along with the out instead when the out finally reaches the source of the in another message is sent from the receiver host to the source host requesting the data to be sent the data finally is transmitted to the destination in response to this data request message our main objection to this system is its lack of symmetry but we do recognize that it does not require any host to buffer data for which a process has not set up an input buffer and perhaps for that reason it is a better system than the msp we are presenting in the last msp variation we considered the difference between send or receive and out or in was discarded in this case only one message is used which we will call transfer when a process executes a transfer it can specify an input buffer an output buffer both or neither two processes wishing to communicate both execute transfers specifying the same to and from port ids and the same rendezvous host the transfers result in transfer messages plus data in the case that an output buffer was specified which rendezvous at the rendezvous host when the rendezvous occurs the transfer messages plus their data cross and each is sent to the source of the other the system allows processes not to know whether they must do a send or receive and is perhaps a nice generalization of the msp presented in this note for instance two processes can exchange data using this system or two processes can kind of interrupt each other by sending dataless transfers this variation of the msp is a development of a suggestion of steve crocker its disadvantages are unintentional matches are more likely to occur rendezvous selection site is more complex and it s hard to think about appendix a system for interprocess communication in a resource sharing computer network communications of the acm april permission to reprint this paper was granted by permission of the association for computing machinery omitted in republished version of rfc n b the ideas of section of the following paper are in no way critical to the ideas developed in section dcw this rfc was put into machine readable form for entry into the online rfc archives by via genie bressler et al experimentation page 