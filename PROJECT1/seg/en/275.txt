 network working group d c walden request for comments bbn inc supercedes nwg rfc august a system for interprocess communication in a resource sharing computer network introduction if you are working to develop methods of communications within a computer network you can engage in one of two activities you can work with others actually constructing a computer network being influenced perhaps influencing your colleagues or you can construct an intellectual position of how things should be done in an ideal network one better than the one you are helping to construct and then present this position for the designers of future networks to study the author has spent the past two years engaged in the first activity this paper results from recent engagement in the second activity a resource sharing computer network is defined to be a set of autonomous independent computer systems interconnected so as to permit each computer system to utilize all of the resources of the other computer systems much as it would normally call a subroutine this definition of a network and the desirability of such a network is expounded upon by roberts and wessler in the actual act of resource sharing can be performed in two ways in an ad hoc manner between all pairs of computer systems in the network or according to a systematic network wide standard this paper develops one possible network wide system for resource sharing i believe it is natural to think of resources as being associated with processes and available only through communication with these processes therefore i view the fundamental problem of resource sharing to be the problem of interprocess communication i also share with carr crocker and cerf the view that interprocess communication over a network is a subcase of general interprocess communication in a multi programmed environment these views have led me to perform a two part study first a set of operations enabling interprocess communication within a single time sharing system is constructed this set of operations eschews many of the interprocess communications techniques currently in use within time sharing systems such as communication through shared memory and relies instead on techniques that can be easily generalized to walden page rfc ipc for resource sharing august permit communication between remote processes the second part of the study presents such a generalization the application of this generalized system to the arpa computer network is also discussed the ideas enlarged upon in this paper came from many sources particularly influential were an early sketch of a host protocol for the arpa network by s crocker of ucla and w crowther of bolt beranek and newman inc bbn ackerman and plummer s paper on the mit pdp time sharing system and discussions with w crowther and r kahn of bbn about host protocol flow control and message routing for the arpa network hopefully there are also some original ideas in this note i alone am responsible for the collection of all of these ideas into the system described herein and i am therefore responsible for any inconsistencies or bugs in the system it must be emphasized that this paper does not represent an official bbn position on host protocol for the arpa computer network a system for interprocess communication within a time sharing system this section describes a set of operations enabling interprocess communication within a time sharing system following the notation of i call this interprocess communication facility an ipc as an aid to the presentation of this ipc a model for a time sharing system is described this model is then used to illustrate the use of the interprocess communication operations the model time sharing has two pieces the monitor and the processes the monitor performs such functions as switching control from one process to another process when a process has used enough time fielding hardware interrupts managing core and the swapping medium controlling the passing of control from one process to another i e protection mechanisms creating processes caring for sleeping processes and providing to the processes a set of machine extending operations often called supervisor or monitor calls the processes perform the normal user functions user processes as well as the functions usually thought of as being supervisor functions in a time sharing system systems processes but not performed by the monitor in the current model a typical system process is the disc handler or the file system system processes is the disc handler or the file system system processes are probably allowed to execute in supervisor mode and they actually execute i o instructions and perform other privileged operations that user processes are not allowed to perform in all other ways user and system processes are identical for reasons of efficiency it may be useful to think of walden page rfc ipc for resource sharing august system processes as being locked in core although they will be of concern later in this study protection considerations are not my concern here instead i will assume that all of the processes are good processes which never made any mistakes if the reader needs a protection structure to keep in mind while he reads this note the capability system developed in should be satisfying of the operations a process can call on the monitor to perform six are of particular interest for providing a capability for interprocess communication receive this operation allows a specified process to send a message to the process executing the receive the operation has four parameters the port defined below awaiting the message the receive port the port a message will be accepted from the send port a specification of the buffer available to receive the message and a location to transfer to when the transmission is complete the restart location send this operation sends a message from the process executing the send to a specified process it has four parameters a port to send the message to the receive port the port the message is being sent from the send port a specification of the buffer containing the message to be sent and the restart location receive any this operations allows any process to send a message to the process executing the receive any the operation has four parameters the port awaiting the message the receive port a specification of the buffer available to receive the message a restart location and a location where the port which sent the message may be noted send from any this operation allows a process to send a message to a process able to receive a message from any process it has the same four parameters as send the necessity for this operation will be explained much later sleep this operation allows the currently running process to put itself to sleep pending the completion of an event the operation has one optional parameter an event to be waited for an example event is the arrival of a hardware interrupt the monitor never unilaterally puts a process to sleep as a result of the process executing one of the above four operations however if a process is asleep when one of the above four operations is satisfied the process is awakened walden page rfc ipc for resource sharing august unique this operation obtains a unique number from the monitor a port is a particular data path to a process a receive port or from a process a send port and all ports have an associated unique port number which is used to identify the port ports are used in transmitting messages from one process to another in the following manner consider two processes a and b that wish to communicate process a executes a receive to port n from port m process b executes a send to port n from port m the monitor matches up the port numbers and transfers the message from process b to process a as soon as the buffer has been fully transmitted out of process b process b is restarted at the location specified in the send operation as soon as the message is fully received at process a process a is restarted at the location specified in the receive operation just how the processes come by the correct port numbers with which to communicate with other processes is not the concern of the monitor this problem is left to the processes when a send is executed nothing happens until a matching receive is executed somewhere in the monitor there must be a table of port numbers associated with processes and restart locations the table entries are cleared after each send receive match is made if a proper receive is not executed for some time the send is timed out after a while and the sending process is notified if a receive is executed but the matching send does not happen for a long time the receive is timed out and the receiving process is notified the mechanism of timing out unused table entries is of little fundamental importance merely providing a convenient method of garbage collecting the table there is no problem if an entry is timed out prematurely because the process can always re execute the operation however the timeout interval should be long enough so that continual re execution of an operation will cause little overhead a receive any never times out but may be taken back using a supervisor call a message resultant from a send from any is always sent immediately and will be discarded if a proper receiver does not exist an error message is not returned and acknowledgment if any is up to the processes if the table where the send and receive are matched up ever overflows a process originating a further send and receive is notified just as if the send or receive timed out the restart location is an interrupt entrance associated with a pseudo interrupt local to the process executing the operation specifying the restart location if the process is running when then event causing the pseudo interrupt occurs for example a message arrives satisfying a pending receive the effect is exactly as if walden page rfc ipc for resource sharing august the hardware interrupted the process and transferred control to the restart location enough information is saved for the process to continue execution at the point it was interrupted after the interrupt is serviced if the process is asleep it is readied and the pseudo interrupt is saved until the process runs again and the interrupt is then allowed any receive or receive any message port may thus be used to provide process interrupts event channels process synchronization message transfers etc the user programs what he wants it is left as an exercise to the reader to convince himself that the monitor he is saddled with can be made to provide the six operations described above most monitors can since these are only additional supervisor calls an example suppose that our model time sharing system is initialized to have several processes always running additionally these permanent processes have some universally known and permanently assigned ports suppose that two of the permanently running processes are the logger process and the teletype scanner process when the teletype scanner process first starts running it puts itself to sleep awaiting an interrupt from the hardware teletype scanner the logger process initially puts itself to sleep awaiting a message from the teletype scanner process via well known permanent send and receive ports the teleype scanner process keeps a table indexed by teletype number containing in each entry a pair of port numbers to use to send characters from that teletype to a process and a pair of port numbers to use to receive characters for that teletype from a process if a character arrives waking up the teletype scanner process and the process does not have any entry for that teletype it gets a pair of unique numbers from the monitor via unique and sends a message containing this pair of numbers to the logger process using the ports for which the logger process is known to have a receive pending the scanner process also enters the pair of numbers in the teletype table and sends the character and all future characters from this teletype to the port with the first number from the port with the second number the scanner process must also pass a second pair of unique numbers to the logger process for it to use for teletype output and do a receive using these port numbers when the logger process receives the message from the scanner process it starts up a copy of what sds tss users call the executive and passes the port numbers to this copy of the executive so that this executive process can also do its inputs and outputs to the teletype using these ports if the logger process wants to get a job number and password from the user it can temporarily use the port numbers to communicate with the user before it passes them on to the executive the scanner process could always use the same port numbers for a particular teletype as long as the walden page rfc ipc for resource sharing august numbers were passed on to only one copy of the executive at a time it is important to distinguish between the act of passing a port from one process to another and the act of passing a port number from one process to another in the previous example where characters from a particular teletype are sent either to the logger process or an executive process by the teletype scanner process the send port always remains in the teletype scanner process while the receive port moves from the logger process to the executive process on the other hand the send port number is passed between the logger process and the executive process to enable the receive process to do a receive from the correct send port it is crucial that once a process transfers a port to some other process the first process no longer use the port we could add a mechanism that enforces this the protected object system of is one such mechanism using this mechanism a process executing a send would need a capability for the send port and only one capability for this send port would exist in the system at any given time a process executing a receive would be required to have a capability for the receive port and only one capability for this receive port would exist at a given time without such a protection mechanism a port implicitly moves from one process to another by the processes merely using the port at disjoint times even if the port s number is never explicitly passed of course if the protected object system is available to us there is really no need for two port numbers to be specified before a transmission can take place the fact that a process knows an existing receive port number could be considered prima facie evidence of the process right to send to that port the difference between receive and receive any ports then depends solely on the number of copies of a particular port number that have been passed out a system based on this approach would clearly be preferable to the one described here if it was possible to assume that all autonomous time sharing systems in a network would adopt this protection mechanism if this assumption cannot be made it seems more practical to require both port numbers note that in the interprocess communication system ipc being described here when two processes wish to communicate they set up the connection themselves and they are free to do it in a mutually convenient manner for instance they can exchange port numbers or one process can pick all the port numbers and instruct the other process which to use however in a particular implementation of a time sharing system the builders of the system might choose to restrict the processes execution of sends and receives and might forbid arbitrary passing around of ports and port numbers requiring instead that the monitor be called or some other special program to perform these functions walden page rfc ipc for resource sharing august flow control is provided in this ipc by the simple method of never starting data transmission resultant from a send from one process until a receive is executed by the receiver of course interprocess messages may also be sent back and forth suggesting that a process stop sending or that space be allocated generally well known permanently assigned ports are used via receive any and send from any the permanent ports will most often be used for starting processes and consequently little data will be sent via them if a process if running perhaps asleep and has a receive any pending then any process knowing the receive port number can talk to that process without going through loggers this is obviously essential within a local time sharing system and seems very useful in a more general network if the ideal of resource sharing is to be reached for instance in a resource sharing network the programs in the subroutine libraries at all sites might have receive anys always pending over permanently assigned ports with well known port numbers thus to use a particular network resource such as a matrix manipulation hardware a process running anywhere in the network can send a message to the matrix inversion subroutine containing the matrix to be inverted and the port numbers to be used for returning the results an additional example demonstrates the use of the fortran compiler we have already explained how a user sits down at his teletype and gets connected to an executive we go on from there the user is typing in and out of the executive which is doing sends and receives eventually the user types run fortran and executive asks the monitor to start up a copy of the fortran compiler and passes to fortran as start up parameters the port numbers the executive was using to talk to the teletype this at least conceptually fortran is passed a port at which to receive characters from the teletype and a port from which to send characters to the teletype fortran is of course expecting these parameters and does sends and receives via the indicated ports to discover from the user what input and output files the user wants to use fortran types input file to the user who responds f fortran then sends a message to the file system process which is asleep waiting for something to do the message is sent via well known ports and it asks the file system to open f for input the message also contains a pair of port numbers that the file system process can use to send its reply the file system looks up f opens it for input make some entries in its open file tables and sends back to fortran a message containing the port numbers that fortran can use to read the file the same procedure is followed for the output file when the compilation is complete fortran returns the teletype port numbers and the ports back to the executive that has been asleep waiting for a message from fortran and then fortran halts itself the file system process goes back to walden page rfc ipc for resource sharing august sleep when it has nothing else to do again the file system process can keep a small collection of port numbers which it uses over and over if it can get file system users to return the port numbers when they have finished with them of course when this collection of port numbers has eventually dribbled away the file system can get some new unique numbers from the monitor a system for interprocess communication between remote processes the ipc described in the previous section easily generalizes to allow interprocess communication between processes at geographically different locations as for example within a computer network consider first a simple configuration of processes distributed around the points of a star at each point of the star there is an autonomous operating system a rather large smart computer system called the network controller exists at the center of the star no processes can run in this center system but rather it should be thought of as an extension of the monitor of each of the operating systems in the network if the network controller is able to perform the operations send receive send from any receive any and unique and if all of the monitors in all of the time sharing systems in the network do not perform these operations themselves but rather ask the network controller to perform these operations for them then the problem of interprocess communication between remote processes if solved no further changes are necessary since the network controller can keep track of which receives have been executed and which sends have been executed and match them up just as the monitor did in the model time sharing system a networkwide port numbering scheme is also possible with the network controller knowing where i e at which site a particular port is at a particular time next consider a more complex network in which there is no common center point making it necessary to distribute the functions performed by the network controller among the network nodes in the rest of this section i will show that it is possible to efficiently and conveniently distribute the functions performed by the star network controller among the many network sites and still enable general interprocess communication between remote processes some changes must be made to each of the four send receive operations described above to adapt them for use in a distributed network controller to receive is added a parameter specifying a site to walden page rfc ipc for resource sharing august which the receive is to be sent to the send from any and send messages is added a site to send the send to although this is normally the local site both receive and receive any have added the provision for obtaining the source site of any received message thus when a receive is executed the receive is sent to the site specified possibly a remote site concurrently a send is sent to the same site normally the local site of the process executing the send at this site called the rendezvous site the receive is matched with the proper send and the message transmission is allowed to take place from the send site to the site from whence the receive came a receive any never leaves its originating site and therein lies the necessity for send from any since it must be possible to send a message to a receive any port and not have the message blocked waiting for a receive at the sending site it is possible to construct a system so the send receive rendezvous takes place at the receive site and eliminates the send from any operation but in my judgment the ability to block a normal send transmission at the source site more than makes up for the added complexity at each site a rendezvous table is kept this table contains an entry for each unmatched send or receive received at that site and also an entry for all receive anys given at that site a matching send receive pair is cleared from the table as soon as the match takes place as in the similar table kept in the model time sharing send and receive entries are timed out if unmatched for too long and the originator is notified receive any entries are cleared from the table when a fulfilling message arrives the final change necessary to distribute the network controller functions is to give each site a portion of the unique numbers to distribute via its unique operation i ll discuss this topic further below to make it clear to the reader how the distributed network controller works an example follows the details of what process picks port numbers etc are only exemplary and are not a standard specified as part of the ipc suppose that for two sites in the network k and l process a at site k wishes to communicate with process b at site l process b has a receive any pending at port m walden page rfc ipc for resource sharing august site k site l process a process b receive port m any process a fortunately knows of the existence of port m at site l and sends a message using the send from any operation from port n to port m the message contains two port numbers and instructions for process b to send messages for process a to port p from port q site k s site number is appended to this message along with the message s send port n site k site l process a process b port n port m send from any to port m site l containing k n p q process a now executes a receive at port p from port q process a specifies the rendezvous site to be site l walden page rfc ipc for resource sharing august site k site l rendezvous table process a process b port p receive message to site l containing p q k a receive message is sent from site k to site l and is entered in the rendezvous table at site l at some other time process b executes a send to port p from port q specifying site l as the rendezvous site site k site l rendezvous table process a process b port p port q send to site l containing p q a rendezvous is made the rendezvous table is cleared and the transmission to port p at site k takes place the send site number and conceivably the send port number is appended to the messages of the transmission for the edification of the receiving process walden page rfc ipc for resource sharing august site k site l process a process b port p port q transmission to port p site k containing data and l process b may simultaneously wish to execute a receive from port n at port m note that there is only one important control message in this system which moves between sites the type of message that is called a host host protocol message in this control message is the receive message there are two other possible intersite control messages an error message to the originating site when a receive or send is timed out and the send message in the rare case when the rendezvous site is not the send site there must also be a standard format for messages between ports for example the following walden page rfc ipc for resource sharing august rendezvous site destination site source site receive port receive port receive port send port send port send port source site data data data transmitted transmitted received by send by network by receive process controller process in the model time sharing system it was possible to pass a port form process to process this is still possible with a distributed network controller remember that for a message to be sent from one process to another a send to port m from port n and a receive at port m from port n must rendezvous normally at the send site both processes keep track of where they think the rendezvous site is and supply this site as a parameter of appropriate operations the receive process thinks it is the send site also since once a send and a receive rendezvous the transmission is sent to the source of the receive and the entry in the rendezvous table is cleared and must be set up again for each further transmission from n to m it is easy for a receive port to be moved if a process sends both the port numbers and the rendezvous site number to a new process at some other site which executes a receive using these same old port numbers and rendezvous site specification the sender never knows the receiver has moved it is slightly harder for a send port to move however if it does the pair of port numbers that has been being used for a send and the original rendezvous site number are passed to the new site the process at the new send site specifies the old rendezvous site with the first send from the new site the receive process will also still think the rendezvous site is the old site so the send and receive will meet at the old site when they meet the entry in the table at that site is cleared and both the send and receive messages are sent to the new walden page rfc ipc for resource sharing august send site just as if they had been destined for there in the first place the send and receive then meet again at the new rendezvous site and transmission may continue as if the port had never moved since all transmissions contain the source site number further receives will be sent to the new rendezvous site it is possible to discover that this special manipulation must take place because a send message is received at a site that did not originate the send message note that the send port and the receive port can move concurrently of course all of this could have also been done if the processes had sent messages back and forth announcing any potential moves and the new site numbers a problem that may have occurred to the reader is how the send and receive buffers get matched for size the easiest solution would be to require that all buffers have a common size but this is unacceptable since it does not easily extend to a situation where processes in autonomous operating systems are attempting to communicate a second solution is for the processes to pass messages specifying buffer sizes if this solution is adopted excessive data sent from the send process and unable to fix into the receive buffer is discarded and the receive process notified the solution has great appeal on account of its simplicity a third solution would be for the receive buffer size to be passed to the send site with receive message and to notify the send process when too much data is sent or even to pass the receive buffer size on to the send process this last method would also permit the network controller at the send site to make two or more sends out of one if that was necessary to match a smaller receive buffer size the maintenance of unique numbers is also a problem when the processes are geographically distributed three solutions to this problem are presented here the first possibility is for the autonomous operating systems to ask the network controller for the unique numbers originally and then guarantee the integrity of any unique numbers currently owned by local processes and programs using whatever means are at the operating system s disposal in this case the network controller would provide a method for a unique number to be sent from one site to another and would vouch for the number s identity at the new site the second method is simply to give the unique numbers to the processes that are using them depending on the non malicious behavior of the processes to preserve the unique numbers or if an accident should happen the two passwords send and receive port numbers that are required to initiate a transmission if the unique numbers are given out in a non sequential manner and are reasonably long say bits there is little danger in the final method a user identification is included in the port numbers and the individual walden page rfc ipc for resource sharing august operating systems guarantee the integrity of these identification bits thus a process while not able to be sure that the correct port is transmitting to him can be sure that some port of the correct user is transmitting this is the so called virtual net concept suggested by w crowther a third difficult problem arises when remote processes wish to communicate the problem of maintaining high bandwidth connections between the remote processes the solution to this problem lies in allowing the processes considerable information about the state of an on going transmission first we examine a send process in detail when a process executes a send the local portion of the network controller passes the send on to the rendezvous site normally the local site when a receive arrives matching a pending send the network controller notifies the send process by causing an interrupt to the specified restart location simultaneously the network controller starts shipping the send buffer to the receive site when transmission is complete a flag is set which the send process can test while a transmission is taking place the process may ask the network controller to perform other operations including other sends a second send over a pair of ports already in the act of transmission is noted and the send becomes active as soon as the first transmission is complete a third identical send results in an error message to the sending process next we examine a receive process in detail when a process executes a receive the receive is sent to the rendezvous site when data resultant from this receive starts to arrive at the receive site the receive process is notified via an interrupt to the specified restart location when the transmission is complete a flag is set which the receive process can test a second receive over the same port pair is allowed a third results in an error message to the receive process thus there is sufficient machinery to allow a pair of processes always to have both a transmission in progress and the next one pending therefore no efficiency is lost on the other hand each transmission must be preceded by a receive into a specified buffer thus continuing to provide complete flow control a potential application only one resource sharing computer network currently exists the arpa computer network in this section i discuss application of the system described in this paper to the arpa network the arpa network currently incorporates ten sites spread across the united states each site consists of one to three potentially four independent computer systems called hosts and one communications computer system called an imp all of the hosts at a site are walden page rfc ipc for resource sharing august directly connected to the imp the imps themselves are connected together by kilobit phone lines much higher rate lines are a potential although each imp is connected to only one to five other imps the imps provide a communications subnet through which the hosts communicate data is sent through the communications subnet in messages of arbitrary size currently about bits called network messages when a network message is received by the imp at the destination site that imp sends an acknowledgment called a rfnm to the source site a system for interprocess communication for the arpa network let us call this ipc for arpa is currently being designed by the network working group under the chairmanship of s crocker of ucla their design is somewhat constrained by the communications subnet i would like to compare point by point ipc for arpa with the one developed in this paper however such a comparison would first require description here almost from scratch of the current state of ipc for arpa since very little up to date information about ipc for arpa appears in the open literature also ipc for arpa is quite complex and the working documents describing it now run to many hundred pages making any description lengthy and inappropriate for this paper therefore i shall make only a few scattered comparisons of the two systems the first of which are implicit in this paragraph the interprocess communication system being developed for the arpa network comes in several almost distinct pieces the host imp protocol imp imp protocol and the host host protocol the imps have sole responsibility for correctly transmitting bits from one site to another the hosts have sole responsibility for making interprocess connections both the host and imp are concerned and take a little responsibility for flow control and message sequencing applications of the interprocess communication system described in this paper leads me to make a different allocation of responsibility the imp still continues to move bits from on site to another correctly but the network controller also resides in the imp and flow control is completely in the hands of the processes running in the hosts although using the mechanisms provided by the imps the imps provide the send receive send from any receive any and unique operations in slightly altered forms for the hosts and also maintain the rendezvous tables including moving of send ports when necessary putting these operations in the imp requires the host host protocol program to be written only once rather than many times as is currently being done in the arpa network it is perhaps useful to step through the five operations again send the host gives the imp a send port number a receive port walden page rfc ipc for resource sharing august number the rendezvous site and a buffer specification e g start and end or beginning and length the send is sent to the rendezvous site imp normally the local imp when a matching receive arrives at the local imp the host is notified of the receive port of the just arrived message this port number is sufficient to identify the sending process although a given operating system may have to keep internal tables mapping this port number into a useful internal process identifier simultaneously the imp begins to ask the host for specific pieces of the send buffer sending these pieces as network messages to the destination site if a rfnm is not received for too long implying a network message has been lost in the network the host is asked for the same data again and it is retransmitted except for the last piece of a buffer the imp requests pieces from the host which are common multiplies of the word size of the source host imp and destination host this avoids mid transmission word alignment problems receive the host gives the imp a send port a receive port a rendezvous site and a buffer description the receive message is sent to the rendezvous site as the network messages making up a transmission arrive for the receive port they are passed to the host along with receive port number and perhaps the send port number and an indication to the host where to put this data in its input buffer when the last network message of the send buffer is passed into the host it is marked accordingly and the host can then detect this it is conceivable that the receive message could also allocate a piece of network bandwidth while making its network traverse to the rendezvous site receive any the host gives the imp a receive port and a buffer descriptor this works the same as receive but assumes the local site to be the rendezvous site send from any the host gives the imp receive and send ports the destination site and a buffer descriptor the imp requests and transmits the buffer as fast as possible a send from any for a non existent port is discarded at the destination site in the arpa network the hosts are required by the imps to physically break their transmissions into network messages and successive messages of a single transmission must be delayed until the rfnm is received for the previous message in the system described here since rfnms are tied to the transmission of a particular piece of buffer and since the hosts allow the imps to reassemble buffers in the hosts by the imp telling the host where to put each buffer piece then pieces of a single buffer can be transmitted in parallel network messages and several rfnms can be outstanding simultaneously this enables the hosts to deal with transmissions of more natural sizes walden page rfc ipc for resource sharing august and higher bandwidth for a single transmission for additional efficiency the imp might know the approximate time it takes for a receive to get to a particular other site and warn the host to wake up a process shortly before the arrival of a message for that process is imminent conclusion since the system described in this paper has not been implemented i have no clearly demonstrable conclusions nor any performance reports instead i conclude with four openly subjective claims the interprocess communication system described in section is simpler and more general than most existing systems of equivalent power and is more powerful than most intra time sharing system communication systems currently available time sharing systems structured like the model in section should be studied by designers of time sharing systems who may see a computer network in their future as structure seems to enable joining a computer network with a minimum of difficulty as computer networks become more common remote interprocess communication systems like the one described in section should be studied the system currently being developed for arpa is a step in the wrong direction being addressed in my opinion more to communication between monitors than to communication between processes and consequently subverting convenient resource sharing the application of the system as described in section is much simpler to implement and more powerful than the system currently being constructed for the arpa network and i suggest that implementation of my method be seriously considered for adoption by the arpa network almost any of the common definitions of a process would suit the needs of this paper or perhaps there is only one permanently known port which belongs to a directory process that keeps a table of permanent process well know port associations that program which prints file directories tells who is on other walden page rfc ipc for resource sharing august teletypes runs subsystems etc the reader should have noticed by now that i do not like to think of a new process consisting of a new conceptual copy of a program being started up each time another user wishes to use the program rather i like to think of the program as a single process which knows it is being used simultaneously by many other processes and consciously multiplexes among the users or delays service to users until it can get around to them i use operating system rather than time sharing system in this section to point up the fact that the autonomous systems at the network nodes may be either full blown time sharing systems in their own right and individual process in a larger geographically distributed time sharing system or merely autonomous sites wishing to communicate for a send from any message the rendezvous site is the destination site for readers familiar with the once proposed re connection scheme for the arpa network the above system is simple comparatively because there are no permanent connections to break and move that is connections only exist fleetingly in the system described here and can therefore be remade between any pair of processes which at any time happen to know each other s port numbers and have some clue where they each are crowther says this is not the virtual net concept as one of the builders of the arpa communications subnet i am partially responsible for these constraints the reader having access to the arpa working documents may want to read specifications for the interconnection of a host to an imp bbn report no and arpa network working group notes this also allows messages to be completely thrown away by the imp subnet it that should ever be useful references ackerman w and plummer w an implementation of a multi processing computer system proc acm symp on operating system principles gatlinsburg tenn walden page rfc ipc for resource sharing august oct carr c crocker s and cerf v host host communication protocol in the arpa network proc afips spring joint comput conf vol afips press montvale n j pp dennis j and vanhorn e programming semantics for multiprogrammed computations comm acm march hansen p b the nucleus of a multiprogramming system comm acm april heart f kahn r ornstein s crowther w and walden d the interface message processor for the arpa computer network proc afips spring joint comput conf vol afips press montvale n j pp lampson b sds lectures circulated informally an overview of the cal time sharing system computer center university of california berkeley calif dynamic protection structures proc afips fall joint comput conf vol afips press montvale n j pp roberts l and wessler b computer network development to achive resource sharing proc afips spring joint comput conf vol afips press monvale n j pp spier m and organick e the multics interprocess communication facility proc acm second symp on operating systems principles princeton university oct author s address d c walden bolt bernakek and newman inc cambridge massachusetts this rfc was put into machine readable form for entry into the online rfc archives by adam costello walden page 