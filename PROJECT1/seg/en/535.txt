 network working group r braden request for comments ucla ccn nic august netcrt a character display protocol at the may nwg meeting ccn circulated dittoed copies of a proposed character display protocol netcrt since that time netcrt has been revised significantly the current version is now being published as an rfc as promised last may netcrt was developed because a particular site rand requested network access to ursa ccn s display based crje system the primary use of ursa at ucla is conversational remote job entry from a display terminal entering and editing program text submitting programs for batch execution and examining job output ursa is not a general purpose time sharing system ursa s text editor is designed for a fast updating character display and cannot be used in any reasonable way from a typewriter like console therefore a simple telnet protocol is not adequate for using the crje function of ursa furthermore we have assumed that other arpa sites will have their own text editors well matched to their own terminals and systems therefore ccn has implemented netrjs see rfc to provide remote job submission and retrieval services before implementing netcrt there are a number of other functions in ursa besides crje some of these would probably be useful to remote users ursa contains a comprehensive status service whose constantly updating displays are windows into the operation of the machine and the operating system allowing a user to watch the progress of his jobs through the system ursa also includes on line data set file utilities convenient for a user with files stored at ccn to obtain access to these facilities a few sites which use ccn heavily may want to implement netcrt the schedule for implementation of netcrt at ccn to allow network access to ursa will depend upon the existence of a user site that wants the service and that will write a suitable netcrt user process interested sites are urged to contact the ccn technical liaison bob braden even though the implementation schedule for netcrt is nebulous we are publishing the specs now for several reasons first we would like comments and criticisms furthermore netcrt contains some features which may be useful in the protocol s now being developed for full graphical displays braden page rfc netcrt a character display protocol august netcrt protocol version a introduction the ucla campus computing network ccn node intends to provide network access to its conversational remote job entry system ursa the ursa system is display oriented supporting only character displays with local buffers originally ibm displays now cci tv display consoles this document defines a third level protocol called netcrt which allows a network user in a remote host to look like a cci console to ursa netcrt is defined in terms of a virtual character display vcd terminal simulated by a process in the user host ursa like many on line console systems attempts to provide a good man machine interaction by keeping tight control over the state of the terminal on the other hand the network working group has deliberately built some squishiness into the standard network protocols we believe this squishiness is a conceptual mistake when dealing with remote man machine interaction and we would support protocol revisions to allow control over the effective communication compliance between processes in different hosts however this netcrt protocol attempts to cope with the present squishiness which is apparently built into a number of host s ncps in fact we have arranged things so a host can improve response time and reduce network traffic with netcrt by using the message buffering inherent in his ncp b the virtual character display a vcd consists of the following virtual hardware see figure a rectangular display screen capable of displaying n lines of m characters a local buffer of m x n characters used to refresh the display a cursor register which addresses the characters in the buffer and hence on the screen this register controls the writing of text into the local buffer from either the keyboard or the server and the reading of the local buffer by the server a keyboard containing text keys and control keys each text key enters a character into local buffer at the current cursor address and steps the cursor register by braden page rfc netcrt a character display protocol august a communication interface through which the server cpu can send a stream of command segments to the vcd and receive a stream of response segments from the vcd the command segments include control commands to the vcd and text to be written into the local buffer response segments contain status indicators and text read from the buffer in addition both vcd and server may send break signals the current address in the cursor register an integer between and m x n is displayed as a blitch underscore or other visual indication at the corresponding point on the screen this indication is called the cursor position is the upper left corner of the screen the screen is addressed in line row order and read and write operations by the server overflow automatically from one line to the next the cursor register is not assumed to operate modulo m x nxsy it is possible for a server command to set the cursor register to m x n one position beyond the last screen position however the server should never set the register to an address beyond m x n and it should not leave the cursor at m x n when the keyboard is unlocked the application program or conversational system using the vcd may format each display screen in a variety of ways and may use a number of styles of interaction one consequence is that the application program might have to look anywhere on the screen i e in the local buffer to find the input information it requires we may consider three alternative mechanisms for transmitting information from the vcd to the serving cpu mechanism whenever the user presses a transmit control key the entire m x n characters in the buffer are transmitted to the server cpu mechanism when the user presses transmit the string of text between a start control character and the cursor is transmitted to the server mechanism the server must send a read command segment to the vcd before the transmit key will have an effect the read command segment determines which parts of the buffer are to be transmitted to the server mechanism may be faulted as too costly in transmission time and channel capacity while mechanism is too restrictive the scheme which we propose here is based on mechanism which subsumes the other two braden page rfc netcrt a character display protocol august the vcd is assumed to include the following control keys erase clears the display buffer to all blanks and resets the cursor to position the upper left corner of the screen transmit locks the keyboard and places the vcd under control of the server cpu typically the server will read specified areas of the screen and perhaps write out new data before unlocking the keyboard again break has the same effect as transmit and in addition sends an interrupt message to the server cpu the break key always sends the interrupt regardless of the state of the vcd reset may be used to unlock the vcd keyboard in case the server cpu fails to respond immediately and the user wishes to enter new or different information these may be called pure control keys since they do not correspond to any text characters the following control key does store a character into the display buffer newline enter a newline nl character into the display buffer and reset the cursor to the beginning of the next line if this character is encountered during a read or write operation it is executed i e the cursor is moved to the beginning of the next line and the nl is counted as one character finally there are assumed to be keys for manually positioning the cursor to any address on the screen cursor positioning keys may include cursor right cursor up cursor left bs cursor down lf and cursor return cr a tab ht mechanism could also be defined although none is included here c vcd states the vcd has two internal states local and control see figure local state the keyboard is unlocked and all keys are active the vcd does not accept or recognize any commands from server except reverse break braden page rfc netcrt a character display protocol august control state the keyboard is locked and only the break and reset keys are active the vcd accepts and executes command segments from the server and returns response segments as the result of read commands the vcd changes from local to control state if either the user presses the transmit key or the user presses the break key or the server sends a reverse break request transmit s only effect is to enter control state break enters control state and also sends a break request ins and x to the server the vcd returns to local state when either the user presses the reset key or the vcd encounters a local command from the server and is not in the process of synchronizing a reverse break see section e below we should note that cci and ibm character display consoles actually have only one control key interrupt on cci enter on to perform the functions of both break and transmit this one key in fact has the function of the break key of the vcd we have included both break and transmit keys in the vcd for generality but the ursa netcrt interface will be programmed to allow a network user of ursa to either employ the break key exclusively or use either break or transmit as appropriate this will be achieved by ursa simply by ignoring those break requests ins messages which occur while there are outstanding read commands d vcd commands the server sends the vcd a string of command segments these are of varying length consisting of an op code and none or more parameters the commands recognized by the vcd are as follows braden page rfc netcrt a character display protocol august display keyboard control commands command parameter s function erase none erase display and reset cursor to i e clear the local buffer blank none disable display refresh i e blank the screen but do not clear the local buffer unblank none enable display refresh local none put vcd in local state the result is to suspend command interpretation and unlock the keyboard sync none used to synchronize reverse break from server sync x is placed in stream by server at same time that it sends an ins vcd enters control state synchronizes ins with break command see next section and continues command interpretation cursor control commands cursor bit integer p set cursor register to p where p m x n find x followed move the cursor to point to an by one character occurrence of the character c c specifically search backwards toward lower addresses from the current cursor position and take the first occurrences of c i e the one with the largest address if no occurrence is found leave cursor at position save none save a copy of the current cursor address in local register s restore none replace cursor register contents by value s braden page rfc netcrt a character display protocol august i o commands write n text bit integer write n bytes of text into display n followed by buffer starting at current cursor n text bytes position and advancing cursor by for each byte except nl character advances to beginning of next line here sigma n m x n read n bit integer read n bytes starting at the cursor n sigma and advancing cursor by one for each byte except nl advances cursor to beginning of next line nl counts as one character send the text to the server as a response segment must have n sigma m x n sread none read s sigma bytes starting from the current cursor position sigma up to but not including the cursor address stored in register s the cursor is left in position s as a result send the text to the server as a response segment awrite n text bit integer same as write n except characters n followed by are not stored in buffer if they n text bytes have a lower cursor address than the value in s here are some applications of these commands in ursa one elementary ursa terminal operation reads the screen from position x up to but not including the current cursor position this could be done with the sequence of vcd command segments save cursor x sread another common operation in ursa is to remember the cursor update specific information on the screen and replace the cursor this can be done by the following n byte sequence of command segments braden page rfc netcrt a character display protocol august save cursor x write n text restore in ursa the area in which a user is to type his response is usually delimited on the left by a start symbol graphic this is a historical remnant of the ibm which has only two hardware read operators read the full screen and read from the start manual input symbol smi to the cursor the smi read operation can be simulated easily on the vcd as follows save find sread the break or transmit key on the vcd may serve the function of the interrupt key on a cci console or enter on an ibm ursa will often attempt to minimize network traffic by sending a sequence of commands one message if allocation allows like the following cursor m write n text ursa writes a request local user types response break user presses transmit key save cursor p ursa reads response sread at other times ursa might send the sequence cursor m write n text local read and wait for the ins from the user pressing break or the response segment triggered by the zero length read if he presses transmit then ursa will send the appropriate read command sequence braden page rfc netcrt a character display protocol august f network message formats the vcd connects the server through icp to a standard socket establishing thereby a pair of connections between the vcd and the server command segments server to vcd and response segments vcd to server are sent over these connections without regard to physical message boundaries using byte size the vcd is defined to operate in a segment at a time mode rather than character at a time with local echo therefore the server never echoes under netcrt in many cases ursa will send a sequence of command segments as in the examples of the preceding section at once if there is sufficient allcocation they will be sent in the same message response time may be improved therefore if the user site is able to buffer ahead on command segments this buffering does raise break synchronization problems which are solved in the following manner for reverse server to user break the server sends an ins on the control link and also a sync command x on the data link to the vcd on receiving either the vcd enters control state and then achieves synchronization between the ins and break if the ins arrives first the vcd executes normally all commands buffered in his host except it ignores local commands until the sync appears having achieved synchronization the vcd continues normal command interpretation without ignoring ensuring local commands by this means the server can regain control of the vcd to write new information at any time for example when ursa is used under netcrt most write or awrite sequences will be preceded by a break from the server since ursa will not know the current state of the vcd even if ursa left the vcd in control state the user might have manually returned his vcd to local state by pressing reset after receiving an ins the vcd executes rather than ignores buffered commands so that pending writes will not be lost in case that processing at the user side has been held up temporarily the read commands executed after the server sent an ins might be irrelevant to a server which can ignore the corresponding response segments in order to do so the server simply keeps matching counts of read commands sent and corresponding response segments received command segments will use the following formats form no parameters q opcode where q x means sync braden page rfc netcrt a character display protocol august x local x erase x blank x unblank x save x restore x sread form bit integer q opcode n integer where q x e means read n q x c cursor n in both cases n m x n form count and text q opcode n length text n where q x d means write q x a means awrite q x f and n means find a response segment caused by a read or sread command has the following format response x a cursor n length text n where n is the number of characters actually read cursor is an integer giving the final cursor position after the corresponding read command note that the command read is permissible and may be used by the server to find the current cursor position or to find out when the user presses transmit braden page rfc netcrt a character display protocol august e screen size for simplicity and consistency with ursa we have chosen to treat the cursor as a single integer this in turn means that vcd and server must agree upon the number of columns m it is also desirable for the server to know n the agreement on m and n takes place through a one sided negotiation the server is assumed to know what m and n values he can handle and these are published for user sites when the vcd is first connected to the server the vcd must send an open response segment with the values m and n open segment x b m n x if the vcd fails to send this segment or the server does not like the values the server closes the connections and the user is considered logged off endnotes graphic representation of start symbol shaded triangle on its side braden page rfc netcrt a character display protocol august d i s p l a y refresh local address buffer text keyboard write read awrite sread control v vcd cursor address control register v s register v comm interface v commands responses network connections figure virtual character display braden page rfc netcrt a character display protocol august keyboard unlocked no commands executed local state break ins received local key send ins command and x executed transmit reset key key v v control state keyboard locked execute commands after ins is received local command is ignored until sync x is encountered figure vcd states this rfc was put into machine readable form for entry into the online rfc archives by lorrie shiota braden page 