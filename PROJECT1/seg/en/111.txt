 network working group george h mealy request for comments harvard university december a proposed user user protocol introduction there are many good reasons and maybe one or two bad ones for making it appear that communication over the network is only a special case of input output at least as far as user programming is concerned thus for instance the harvard approach toward implementing the host host protocol and network control program treats each link as a logical device in pdp terminology setting up a connection is similar to local device assignment and communication over a link will make use of the standard system input output uuo s this makes it possible to use existing programs in conjunction with the network without modification at least if other pdp s are being dealt with this takes us only so far however the notion of a logical device does not exist on the pdp it does on the ibm i am speaking here at the level of the operating system user program interface furthermore in the absence of a network standard requiring fixed representations for integers reals etc which i would oppose any pair of user processes must arrive at a local agreement and one or both must assume the burden of data conversion where necessary any standard protocol should allow such agreements to be given expression and should accommodate at least the minimum of control information that will allow such agreements to function in practice finally we must note that the imp imp and host host protocols do not provide for a check that an action requested by a user process is actually accomplished by the other processes this type of issue has always been regarded as subject to treatment at the user user protocol level this proposal is intended to face the above three types of issue only to a certain extent i can best explain that extent by stating the criteria i would use to judge any user user protocol proposal mealy page rfc a proposed user user protocol december the notion of a logical record should be present and the notion of a message should be suppressed to a fortran pro grammer that which is written using one write statement with no accompanying format is a record to an os machine language programmer put writes a record it should be possible to so implement the protocol in host sys tems and or library routines that now existing user programs can access files anywhere in the network without program modifica tion initially at least this ability must be restricted to host systems of the same type the protocol should be implementable not necessarily imple mented in any host system at the svc or uuo level specific knowledge of the characteristics of the other host involved should be unnecessary it should be noted that the above imply that some user programs must be aware of the nature of the other host at least in each case where the second criterion fails as we make progress in or give up on the cases where the failure now occurs the burden of accommodat ing system differences will shift toward implementation in protocols i e the host systems or by default in user programs quite clearly any proposal initiated today should be suspect as to the extent to which it solves ultimate problems how ambitious to be is strictly a matter of taste at this stage i prefer to try something which i believe can be used by all of us and hence is worth doing goes a reasonable distance towards solving our short range problems is easy to do and offers hope of viability in the long range view in the following i intend to describe the proposal itself with i hope proper motivational arguments for its pieces i will then sketch the specific implementation we at harvard are making for the pdp and describe how we intend to apply it in the specific case of storage of files on other pdp s in the network user user protocol proposal the following protocol is intended to apply to the data bits in mes sages between the end of the marking bits and the beginning of the padding bits the present imp imp and host host protocols are unaf fected by this proposal the general principle is that each segment this is not a technical term of data is preceded by control information specifying its nature and extent the basic scheme has been evolved from that used in the sos buffering system see the papers in jacm april and especially that by o r mock mealy page rfc a proposed user user protocol december our point of view is that a link is a carrier of information infor mation is carried in segments of a fixed maximum length called mes sages that this is so is an accident from the user s point of view when he wishes to transmit a contiguous stream of data he will in general segment it in a different from the imp imp or host host protocol view manner we will call his segment a record it should be clear that this is entirely analogous between the notion of physical block and logical record on the side file storage systems also make use of control and status information we will also at the user user protocol level all information transmitted over the link is a sequence of flags followed by possibly null data blocks the general format will be operation count data the operation field is always present and is four bits long the count field when present gives the number of data bytes following in the data block the byte size is set by the last preceding size flag in most cases the byte may be between zero and bits long yes virginia zero is zero even when you have a system the operation field and the count field when present are called the flag and the data bytes when present the data block flags fol lowed by data blocks even when null due to a zero count are called block flags and other flags are called whyte flags it is to be noted that since the size flag sets the byte size for the following blocks byte size may be set at that natural for the sending or for the receiving host depending on local agreement between the sending and receiving processes it is specifically required that a size flag appear in each message prior to any block flag except the ascii flag the size flag may be introduced on a default basis by the routine s implementing the protocol and is intended partially as a means of detecting certain classes of error the count field is bits in length except in the eom flag where it is bits long the flags are as follows whyte flags nul no operation consider next flag rs record separator end of record gs group separator end of group fs file separator end of file esc escape to local convention for flags reserved for later assignment mealy page rfc a proposed user user protocol december eom n end of message n is total bit count size n byte size is n bits ignore n ignore following data bits block flags sys n n bytes of data for receiving host system control n n bytes of control data follow status n n bytes of status data follow label n n bytes of identification data follow key n n bytes of key data follow ascii n n bit bytes of ascii data follow block n n bytes of data follow i have already mentioned the requirement for size absence of the size flag in any message containing block flags except ascii is a definite error eom is partially another error checking device and partially a device for bypassing the padding conundrum a user pro gram should never see eom on input the user may write an eom to force transmission eom delimits the end of the useful information in the message and restates the total number of bits in the message starting with the first bit following the marking and ending with the last bit of the eom count field to check possible loss of informa tion this is a check against errors in the imp host electrical interface and in the host mushyware eom must appear at the end of each messager unless esc has apeared esc is intended as a hopefully unused escape hatch for nonuse by those installations and or applications wishing to avoid using more than four bits of the user user protocol on any link for instance it may be desired to use a link as a bit stream ignoring even mes sage boundaries if and when anarchists can achieve local agreement more power to them nul and ignore are intended to be space fillers in case it is help ful to make the first bit of the subsequent data block occur on a convenient address boundary an especially helpful host interrupt routine might even paste a combination of nul and ignore over the marking bits when receiving a message in which case their bit count should be transmitted on to the get routines to correct the eom bit count check the separator operations introduce the notions of logical record group and file specifically there is no require ment that a record be contained entirely within a message or that only a single record be contained in a message in addition there is no requirement that only one file be transmitted during a connec tion for instance a user might wish to use a link to transmit a collection of rountines and then do something else with the link mealy page rfc a proposed user user protocol december by local agreement then a single routine might consist of a number of records forming a group the whole collection might form a file and the link might remain connected after the fs flag is received the interpretation of the various block flags is similarly open to local agreement the two flags intended to convey pure data are ascii and block the difference between them is only as far as the protocol is concerned that the byte size is implicit for ascii bits and explicit for block the count field of the next preceding size flag beyond this however the semantic content of the block following ascii is governed by the current standards for ascii ebcdic information may not be transmitted in an ascii block control and status are intended for communication of control informa tion between user processes and the interpretation of their accom panying data blocks is open to local agreement generically control means try to do the following and status means but i feel this way doctor a control flag will prompt a returned status flag sooner or later or never label is intended for use in identifying the following unit s of data at the file or group level again the specific interpretation is a matter of local agreement key is intended to mimic the notion of address or key this is at the record data item or even physical storage block level for the familiar with pdp system and or os the following parallels are offered for guidance user user protocol os pdp control open open close close label dscb file retrieval information key key useti useto argument control read in input write out output allocate enter open lookup status getsts mealy page rfc a proposed user user protocol december the notations above indicate lack of a very direct parallel it is worth noting that the os get and put have direct parallels in any implementation of the user user protocol that embodies the notion of record our implementation of the protocol will lead to introduc tion of this notion for all pdp input output involving disc and tape storage as well as imp communication if i knew the multics terminology i could extend the set of paral lels above with more precision although my terminology has been drawn from systems with explicit input output imperatives i wish to emphasize that this setup in intended to handle control and data com munication in general multics is a system in which the classical distinction between external and internal storage is blurred from the user s point of view in a manner i wish it blurred in the user user protocol i offer sys with only slight trepidation the gen eral notion is that one should be able to communicate directly with a foreign host rather than via a foreign user process as its intermedi ary sys is like a uuo or svc but for the foreign host s consump tion rather than my host s from the host s point of view the prob lem in implementation is in establishing a process context record unconnected with any local user process this however is strongly associated with our current logon conundrum on the pdp for instance users are more or less identified with local teletype lines and any link is not one of those hence subterfuge is neces sary to let a foreign user log on os is as actually more perverse in its own way the process of logging a foreign process onto my local system is not except possibly for multics a simple matter of having a special user job present which is responsible for doing it when and if anything else is possible the host must provide a system instruc tion uuo or svc or whatever that gives the requisite information establishing a process independent in all senses of the process that made the request otherwise self protection mechanisms which are reasonable for any system will make us all much more interdependent that we wish to do this there must exist in every system a uuo svc that does the right thing attach but forget me if this is true then the logon process over the network is tantamount to issuance of a foreign uuo svc by another node in the network i see no reason able way around this if that is the case then sys n is the kind of flag to use to convey the requisite data if that is so then it is only reasonable to let sys convey a request for any os instruction at the user program operating system interface level the practical questions of implementation are something else in the case of the pdp i can pretty well see how to turn a sys into either a logon request to execute a monitor command or uuo would that they were the same as the case might be os is more mealy page rfc a proposed user user protocol december sophisticated unfortunately multics might make it naytheless i hope that is clear that what we want to do which is what the proto col should reflect is quite a different question from that of how it is to be done in the context of a specific host system what we want to do is in general rather independent of the system we are dealing with as far as the protocol is concerned and we should not fail to introduce general notions into the protocol just because we are unc ertain as to how they may have to be translated into particular implementation practice a pdp implementation although the following can be implemented as either a set of user routines or imbedded in the monitor as uuo s our first implementa tion will be the former the latter version will be used for descriptive purposes the uuo s would be putf ch e put flag putd ch e put data put ch e put record getfd ch e get flag or data get ch e get record in the above ch is the logical channel number the customary open or init uuo is used to open the channel standard format user buffers are assigned however the ring and buffer headers will be used in a nonstandard way so that data mode is assigned for use with network buffering and file status bit must be on for input any of the devices dsk dta mta or imp can be used in this mode in the harvard ncp and host host protocol implementation user buffers do not correspond directly to messages on output each user buffer will be formatted into a message on input a message may become one or two user buffer loads word buffers are used in order to make maximum use of the facilities of the disk service rou tines mealy page rfc a proposed user user protocol december putf uuo this uuo places a flag into the output buffer the effective address is the location of a word xwd operation count in the case of block flags the count is ignored since it will be computed from the number of bytes actually placed in the buffer before the next use of putf putf and putd will insert eom flags automatically as each buffer becomes full if data bytes are currently being placed in the buffer by putd it will also insert an eom flag after computing the count for the previous block flag in the buffer and place a new block flag of the same type at the beginning of the next buffer after inserting a size flag stating the then current byte size putd uuo this uuo places data into the output buffer the effective address is the location of the data byte if the byte size is less than or of the next bit word of data to be placed in the buffer in the first case the byte is assumed to be in the low order part of the word addresses in the second case the data word containing the final bits of the byte contains them in the high order part of the word and the next data byte starts a new word in pdp storage thus for a byte size of two entries to putd would be used per byte transmitted the first containing bits and the second containing bits left justified this strategy allows maximum use of the pdp byte handling instruc tions put uuo this uuo places a whole logical record in the output buffer s the effective address is that of a word iowd count location a putf uuo must have been used to output the proper size flag thereafter each use of put will output a block flag simulate a number of calls to putd using the iowd to discover the location and size of the user data area and then output a rs flag to indi cate end of record mealy page rfc a proposed user user protocol december in the case of byte size of less than bits put will use the ildb instruction to pick up bytes to be output by putd hence the standard pdp byte handling format is used and the count part of the iowd is the total byte count not word count the above uuo s have both an error return and a normal return getfd uuo the calling sequence for this uuo is getfd ch e error return whyte flag return block flag return data return the effective address is the location at which the flag or data will be returned the flag is returned in the same format as for putf and the data in the same format as for putd certain flags nul ignore and eom will be handled entirely within the uuo and will not be reported to the user sys should eventually be han dled this way but initially will be handled by the user get uuo the calling sequence for this uuo is get ch e error return end of file return end of group return normal return get transmits the next logical record to the user using getfd together with an iowd in the same format as for put if the iowd count runs out before end of record the remainder of the record will be skipped in any case the updated iowd will be returned at the effective address of the uuo in order to inform the user how much data was transmitted or skipped pdp file transmission assume that i have a link connected to another pdp and a user process there that is listening in order to get that process to send me a file the sequence of flags that might be transmitted can mealy page rfc a proposed user user protocol december be represented as follows where the uuo s executed by me are in the left margin the flags are indented and the commentary opposite them indicates the nature of the data block transmitted put f control data with open parameters requesting open label file identification data for lookup eom forces message to be transmitted getfd status status returned by open size byte size to be used label file retrieval information putf control data requesting input from file eom forces request to be transmitted getfd status status bits returned by input get logical record one file buffer load loop back to second putf above for other records finally the status information returned by the second getf indicates end of file and i wind up with the sequence putf control data requesting a close eom forces transmission getfd status status bits returned by close in the case i am getting a file the main loop looks like putf control data requesting output put logical record one file buffer load putf eom forces transmission getfd status status bits returned by output mealy page rfc a proposed user user protocol december the use of both the record and the flag transmission uuo s is worth noting as well as the use of the eom flag to force transmission of a message when switching between input and output over the link put and get uuo s are clearly required above for transmission of the con trol and label data i suppressed them for the sake of clarity for this application the handshaking nature of the transmission of control and status flags are mandatory while the protocol would permit transmission of a complete file without the handshaking it would be an all or nothing proposition a single error would neces sitate doing it all over again presuming that the receiving process did not end up in a complete tangle brief discussion the pdp space required to implement the above protocol is about instructions divided equally between the input and the output side enough experimental coding has been done to confirm the feasi bility of this basic strategy taken together with experience with implementation and use of the sos buffering system the above does not touch the question of logon protocol except indirectly my belief is that it can be accommodated in the frame work of this proposal but i have not tested this theory as yet as indicated further above i would be tempted to handle the matter with the sys flag given that sys data is interpreted directly by the sys tem in our system we would use the run uuo to run the logon cusp which would in turn handshake using ascii data over the link in this way i think we might be able to dispense with the notion of dedicated sockets and the reconnection morass one other point that needs thought is the question of how to handle the interrupt on link facility should it have any direct relation to the get put uuo s or be handled on the side i am inclined to think that it should be treated qua interrupt of the user process quite independently of the matter of data transmission over the link some of our current work on the pdp monitor would lend itself rather easily to implementation as a true interrupt endnotes a message is that string of bits between any two host host headers in memory of an attractive but nonspelling sdc secretary who could not distinguish between black and white at least during and in manuscript form mealy page rfc a proposed user user protocol december putf may be used to ouput the block flag if a different from block is required this rfc was put into machine readable form for entry into the online rfc archives by colin barrett mealy page 