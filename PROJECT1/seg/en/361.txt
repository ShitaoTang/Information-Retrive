 network working group j newkirk request for comments m kraley harvard j postel s crocker ucla june a prototypical implementation of the ncp while involved in attempting to specify the formal protocol we also attempted to formulate a prototypical ncp in an algol like language after some weeks of concentrated effort the project was abandoned as we realized that the code was becoming unreadable we still however felt the need to demonstrate our conception of how an ncp might be implemented we felt that this would help suggest solutions for problems that might arise in trying to mold the formal specifications into an existing system this document is that attempt to specify in a prose format what an ncp could look like there are obvious limitations on a project of this nature we do not and cannot know all of the quirks of the various systems that must write an ncp we are forced to make some assumptions about the environment system calls and the like we have tried to be as general as possible but no doubt many sites will have completely different ways of conceptualizing the ncp there is great difficulty involved in conveying our concepts and the mechanisms that deal with these concepts to people who have wholly different ways of looking at things we have however benefited greatly by trying to actually code this program for our fictitious machine many unforeseen problems surfaced during the coding and we hope that by issuing this document we can help to alleviate similar problems which may arise in individual cases there is of course absolutely no requirement to implement anything which is contained in this document the only rigid rules which an ncp must conform to are stated in nwg rfc this description is intended only as an example not as a model in the discussion which follows we first describe the environment to be assumed and postulate a set of system calls we discuss the overall architecture of the ncp and the tables that will be used to hold relevant information narratives of network operations follow a state diagram is then presented as a convenient method for conceptualizing the cause effect sequencing of events the detailed processing of each type of network event system calls or incoming network messages is then discussed newkirk et al page rfc prototypical implementation of ncp june ii environment we assume that the host will have a time sharing operating system in which the cpu is shared by processes we envision that each process is tagged with a user number there may be more than one process with the same user number if so they should all be cooperating with respect to using the network we envision that each process contains a set of ports which are unique to the process these ports are used for input to or output from the process from or to files devices or other processes we also envision that a process is not put to sleep i e blocked or dismissed when it attempts to listen or connect instead it is informed when some action is complete of course a process may dismiss itself so that it wakes up only on some external event to engage in network activity a process attaches a local socket to one of its ports sockets are identified by user number host and aen a socket is local to a process if the user numbers of the two match and they are in the same host thus a process need only specify an aen when it is referring to a local socket each port has a status which is modified by system calls and concurrent events outside the process e g a close connection command from a foreign host the process may look at a port s status as any time via the status system call we assume a one to one correspondence between ports and sockets iii system calls these are typical system calls which a user process might execute we use the notation syscall arg arg where syscall is the name of the system call and argk etc are the parameters of the system call newkirk et al page rfc prototypical implementation of ncp june connect p aen fs cr p specifies a port of the process aen specifies a local socket the user number and host are implicit fs specifies a socket with any user number in any hose and with any aen cr the condition code returned connect attempts to attach the local socket specified by aen to the port p and to initiate a connection with a specific foreign socket fs possible values of cr are cr ok the connect was legal and the socket fs is being contacted when the connection is established or refused the status will be updated cr busy the local socket is in use illegal command sequence cr badskt the socket specification was illegal cr noroom local host s resources are exhausted cr homosex incorrect send receive pair cr imp dead our imp has died cr link dead the link to the foreign host is dead because the foreign imp is dead the foreign host is dead or the foreign ncp does not respond listen p aen cr p specifies a port of the process aen specifies a local socket cr the condition code returned the local socket specified by aen is attached to port p if there is a pending call it is processed otherwise no action is taken when a call comes in the user will be notified after examining the call he may either accept or refuse it possible values of cr are cr ok connection begun listening cr busy newkirk et al page rfc prototypical implementation of ncp june cr noroom cr imp dead cr link dead accept p cr p specifies a port of the process cr the condition code returned accept implies that the user process has inspected the foreign socket to determine who is calling and will accept the call note an interesting alternative defines accept as the implicit default condition thus any incoming rfc automatically satisfies a listen possible values of cr are cr badskt cr noroom cr imp dead cr link dead cr badcomm illegal command sequence e g accept issued before a listen cr premcls foreign user aborted connection after rfc was locally received but before accept was executed transmit p buff bitsrqst bitsacc cr p specifies a port of the process buff specifies the text buffer for transmission bitsrqst specifies the length to be transmitted in bits bitsacc returns the number of bits actually transmitted cr the condition code returned transmission takes place possible values for cr are cr ok cr imp dead cr link dead newkirk et al page rfc prototypical implementation of ncp june cr not open connection is not open illegal command sequence cr bad bound bitsrqst out of bounds e g for a receive socket buff was shorter than bitsrqst indicated int p cr p specifies the local socket of this process cr the condition code returned the process on the other foreign side of this port is to be interrupted possible values of cr are cr ok cr badskt cr badcomm cr imp dead cr link dead status p rtab cr p specifies a port of this process rtab the returned rendezvous table entry cr the condition code returned the relevant fields of the rendezvous table entry associated with this port are returned in rtab this is the mechanism a user process employs for monitoring the state of a connection possible values of cr are cr ok cr badskt newkirk et al page rfc prototypical implementation of ncp june close p cr p specifies a port of this process cr the condition code returned activity on the connection attached to this port stops the connection is broken and the port becomes free for other use possible values of cr are cr ok cr badskt cr badcomm cr imp dead cr link dead iv the ncp gross structure we view the ncp as having five component programs several associative tables and some queues and buffers the component programs see fig the input handler this is an interrupt driven routine it initiates imp to host transmission into a resident buffer and wakes up the input interpreter when transmission is complete the output handler this is an interrupt driven output routine it initiates host to imp transmission out of a resident buffer and wakes up the output scheduler when transmission is complete the input interpreter this program decides whether the input is a regular message intended for a user a network control message an imp to host message or an error for each class of message this program invokes a subroutine to take the appropriate action newkirk et al page rfc prototypical implementation of ncp june the output scheduler three classes of messages are sent to the imp a host to imp messages b control messages c regular messages we believe that a priority should be imposed among these classes the priority we suggest is the ordering above the output scheduler selects the highest priority message and passes it to the output handler host to imp messages are processed first come first served control messages are processed individually by host each host being taken in turn a control message queue for each foreign host is provided when any particular host is scheduled for output as many control commands for that host as will fit are concatenated into a single message regular messages are processed in groups by host and link each unique combination being taken in turn the system call interpreter this program interprets requests from the user each system call has a corresponding routine which takes the appropriate action the two interesting components are the input interpreter and the system call interpreter these are similar in that the input interpreter services foreign requests and the system call interpreter services local requests the diagram in figure is our conception of the network control program squishy amoeba like objects represent component programs cylinders represent queues and the arrows represent data paths in this simplified diagram tables are not shown amoeba like objects in original hand drawing are now firm rectangular boxes ed the abbreviated labels in the figure have the following meanings hiq host to imp queue occq output control command queue dq data queue ihbuf input handler buffer ohbuf output handler buffer newkirk et al page rfc prototypical implementation of ncp june user structure of the network control program fig v system call interpreter input interpreter v v v v d q o c c q h i q v v v output scheduler v o h b u f i h b u f v output input handler handler v i m p newkirk et al page rfc prototypical implementation of ncp june v tables in the ncp we envision that the bulk of the ncp s data base is in associative tables by associative we mean that there is some lookup routine which is presented with a key and either returns successfully with a pointer to the corresponding entry or fails if no entry corresponds to the key the major tables are as follows the rendezvous table this table holds the attributes of a connection the table is accessed by the local socket but other tables may have pointers to existing entries the components of an entry are a local socket b foreign socket c link d connection state e flow state f data queue g call queue h port pointer i their buffer size only needed on the send side j error state an entry is created when either a connect or a listen system call is executed or when a request for connection is received various fields remain unused until after the connection is established the input link table the input interpreter uses the concatenation of the foreign host and link as a key into the input table the table is used in processing a user destined message on an incoming link by providing a pointer into the rendezvous table the output link table the input interpreter uses the output link table to access the flow state as rfnm s return from transmitted messages the output link table is keyed by host and link and provides a pointer into the rendezvous table newkirk et al page rfc prototypical implementation of ncp june the port table the system call interpreter uses the concatenation of the process identification and the port identification as a key to obtain a pointer into the rendezvous table the output control command table the system call interpreter and the input interpreter use this table to make entries in the appropriate output control command queues commands are queued in separate table entries corresponding to foreign hosts before output the contents of the queue are concatenated into a large control message the components of an entry are a host b output control command queue the output request queue this queue contains an entry for each connection which has data requiring transmission to the net there is only one entry per connection which is deleted when the last packet of data is transmitted and is entered whenever a user makes a system request for data transmission the entry is re inserted if transmission is not completed message too long or is prevented by the flow control mechanism the only component of an entry is a local socket the host live table this is a simple table listing the hosts which are alive this table is checked before establishing a connection and before sending any data to ensure that the destination host actually exists at present the protocol does not define the procedure to be followed for the host up host down conditions see nwg rfc the link assignment table link numbers are assigned by the receiver this table records which links are free and can therefore be assigned newkirk et al page rfc prototypical implementation of ncp june vi informal description of network operations we present here narratives describing the operation conducted during the three major phases of network usage opening flow control and closing a opening in order to establish a connection for data transmission a pair of rfc s must be exchanged an rts must go from the receive side to the send side and an str must be issued by the send side to the receive side in addition the receive side in its rts must specify a link number these rfc s rfc is a generic term encompassing rts and str may be issued in any time sequence a provision must also be made for queuing pending calls i e rfc s which have not been dealt with by the user program thus when a user is finished with a connection he may choose to examine the next pending call from another process and decide to either accept or refuse the request for connection a problem develops because the user may not choose to examine his pending calls thus they will merely serve to occupy queue space in the ncp several alternative solutions to this problem will be mentioned later utilizing the framework of the prototype system calls described above we envision at least four temporal sequences for obtaining a successfully opened connection the user may issue a listen indicating he is willing to consider connecting to anyone who sends him an rfc when an rfc comes in the user is notified the user then decides whether he wishes to connect to this socket and issues an accept or a close on the basis of that decision a close refuses the connection as discussed under closing an accept indicates he is willing to connect an rfc is issued and the connection becomes fully opened upon processing a user request for a listen the ncp discovers that a pending call exists for that local socket the user is immediately notified and he may accept or close as above the user issues a connect specifying a particular foreign socket that he would like to connect to an rfc is issued if the foreign process accepts the request it answers by returning an rfc when this acknowledging rfc is received the connection is opened newkirk et al page rfc prototypical implementation of ncp june when presented with a connect the ncp may discover that a pending call exists from the specified foreign socket to the local socket in question an acknowledging rfc is issued and the connection is opened in all of the above cases the user is notified when the connection is opened but data flow cannot begin until buffer space is allocated and an all command is transmitted any of these connection scenarios will be interrupted if a cls comes in as discussed under closing pending call queues it is essential that some form of queuing for pending rfc s be implemented a simple way to see this is to examine a typical listen connect sequence one side issues a listen the other a connect if the listen is issued before the rfc coming from the remote connect arrives all is fine however due to the asynchronous nature of the net we can never guarantee that this sequence of events will occur if calls are not queued and the rfc comes in before the listen is issued it will be refused if it arrives later it will be accepted thus we have an extremely ambiguous situation unless one has infinite queue space it is desirable that some mechanism for purging the queues of old rfc s which the user never bothered to examine an obvious but informal method is to note the time when each rfc is entered into the queue and then periodically refuse all rfc s which have exceeded some arbitrary time limit another thought which probably should be included within the context of any scheme is for the ncp to send a cls on all outstanding connections or pending calls when a user logs out or blows up the scheme which is utilized in this description may seem at first blush to be non intuitive but we feel it is more realistic than other proposals basically when a connect is issued the ncp assumes that this socket wishes to talk to the specified foreign socket and to that socket only it therefore purges from the pending call queue all non matching rfc s by sending back cls s similarly when the connection is in the rfc send state a connect has been issued all non matching rfc s are refused if a listen accept or listen close sequence is executed the remainder newkirk et al page rfc prototypical implementation of ncp june of the pending calls are not removed from the queue in the expectation that the user may wish to accept these requests in the future although the latter method may seem to be arbitrary and or unnecessarily restrictive we have not yet concocted a scenario which would be prohibited by this method assuming that we are dealing with a competent programmer i e one who is wary of race conditions and the asynchronous nature of the net of course whatever scheme or schemes a particular site chooses is highly implementation dependent we suggest that some provision for the queuing of rfc s be provided for a period of time at least of the order of magnitude that they are retained in the connect clear scheme mentioned above b flow control meaningful data can only flow on a connection when it is fully opened i e two rfc s have been exchanged and closing has not begun we assume that the ncp s have a buffer for receiving incoming data and that there is some meaningful quantity which they can advertise on a per connection basis indicating the size message they can handle we further assume that the sending side regulates its transmission according to the advertisements of that size when a connection is opened a cell called their size is set to zero the receive side will decide how much space it can allocate and send an all message specifying that space the send side will increment their size by the allocated space and will then be able to send messages of length less than or equal to their size when messages are transmitted the length of the message is subtracted from their size when the receive side allocates more buffer space e g when a message is taken by the user thus freeing some system buffer space the number of bits released is sent to the send side via an all message thus their size is never allowed to become negative and no transmission can take place if their size equals zero notice that the lengths specified in all messages are increments not the absolute size of the receiving buffer this is necessitated by the full duplex nature of the flow control protocol the length field of the all message can be bits long note this is an unsigned integer thus providing the facility for essentially an infinite bit sink if that may ever be desired newkirk et al page rfc prototypical implementation of ncp june c closing just as two rfc s are required to open a connection two cls s are required to close a connection closing occurs under various circumstances and serves several purposes to simplify the analysis of race conditions we distinguish four cases aborting refusing termination by receiver termination by sender a user aborts a connection when he issues a connect and then a close before the connect is acknowledged typically a user will abort following an extended wait for the acknowledgment his system may also abort for him if he blows up a user refuses a connection when he issues a listen and after being notified of a prospective caller issues a close any requests for connection to a socket which is expecting a call from a particular socket are also refused after a connection is established either side may terminate the required sequence of events suggests that attempts to close by the receive side should be viewed as requests which are always honored as soon as possible by the send side any data which has not yet been passed to the user or which continues over the network is discarded requests to close by the send side are honored as soon as all data transmission is complete aborting we may distinguish three cases a in the simplest case we send an rfc followed later by a cls the other side responds with a cls and the attempt to connect ends b the foreign process may accept the connection concurrently with the local process aborting it in this case the foreign process will believe the local process is terminating an open connection c the foreign process may refuse the connection concurrently with the local process aborting it in this case the foreign process will believe the local process is acknowledging its refusal newkirk et al page rfc prototypical implementation of ncp june refusing after an rfc is received the local host may respond with an rfc or a cls or it may fail to respond the local host may have already sent its own rfc etc if the local host sends a cls the local host is said to be refusing the request for connection we require that cls commands be exchanged to close a connection so it is necessary for the local host to maintain the rendezvous table entry until an acknowledging cls is returned terminating by the sender when the user on the send side issues a close system call his ncp must accept it immediately but may not send out a cls command until all the data in the local buffers has been passed to the foreign host it is thus necessary to test for both buffer empty and rfnm received before sending the cls command as usual the cls must be acknowledged before the entry may be deleted terminating by the receiver when the user on the receive side issues a close system call his ncp accepts and sends the cls command immediately data may still arrive however and this data should be discarded the send side upon receiving the cls should immediately terminate the data flow vii connection status an excellent mechanism for describing the sequence of events required to establish and terminate a connection involves a state diagram we may assume that each socket can be associated with a state machine and that this state machine may at any time be in one of ten possible states in any state certain network events cause the connection status to enter another state other events are ignored still others are error a transition may also involve the local ncp performing some action figure depicts the state machine circles now boxes ed represent states described below arrows show legal transitions between states the labels on the arrows identify the event which caused them note that close is a system call cls is a control command phrases after slashes denote the action which should be performed while traveling over that arrow the arrow labeled e rfc found between states and represents newkirk et al page rfc prototypical implementation of ncp june the condition that whenever a connection enters the closed state the pending call queue for that connection is checked original was backwards e ed if any pending calls exist in the queue the connection moves to the pending state if an rfc is received for a socket in the closed state it is also moved along this path to the pending state events and the actions they cause are described in sections viii and ix below descriptions of the ten states follow closed the local socket is not attached to any port and no user has requested a connection with it the table entry is non existent pending call the socket is not attached to any port but one or more requests for connection have been received a listen system call will be satisfied immediately by the first entry in the pending call queue for a matching request all other pending calls are deleted listening the socket is attached to a port we are waiting for a user to request connection with this socket rfc rcvd we are listening and an rfc was received the local user has been informed of the pending call he must respond with either a close or an accept abort we have notified the user that his listen has been satisfied but he has not yet responded if during this time the foreign user aborts the connection by sending a cls we send a cls to acknowledge the abort and mark the fact with this state when the user accepts or refuses the call we can inform him the connection has been prematurely terminated newkirk et al page rfc prototypical implementation of ncp june rfc sent this state is entered when a the local user has attached this socket to a port by issuing a connect b an rfc has been sent and c no reply has been received when the user issues a connect the pending call queue is searched if a matching rfc is not found the queue is deleted and this state is entered as new rfc s arrive they are compared with our user s request if they do not match the rfc is immediately refused if the rfc matches it completes the initialization process and the connection enters the open state open rfc s have been exchanged and the connection is securely established transmission may begin following receipt of an all command from the receive side and will then proceed subject to flow control cls wait after the local user has executed a close and we have issued a cls we must wait for an acknowledging cls before the connection can be completely closed if the appropriate cls has not already been received this state is entered data wait if we are on the send side and the local user executes a close system call a cls cannot be issued if our data buffer is not empty or if a rfnm for the last data message is outstanding the connection enters this state to wait for these conditions to be fulfilled upon completion and acknowledgement of output a cls may be issued and the connection enters the cls wait state waiting for the acknowledging cls if a cls arrives while in the data wait state we clear our buffer the cls came from a receive socket indicating it is no longer interested in our data and enter the rfnm wait state to wait for the network to clear newkirk et al page rfc prototypical implementation of ncp june rfnm wait if we are on the send side and a cls command arrives we cannot issue an acknowledging cls if we have not received the rfnm for our last data message we enter this state to await the rfnm and cease all further data transmission when the rfnm comes in a cls may then be issued and the connection will be closed newkirk et al page rfc prototypical implementation of ncp june close conn closed send rfc listen e rfc cls send cls v v non matching conn send rfc pending listen rfc listening matching v v conn send rfc v v accept cls rfc sent rfc send rfc rfc recd send cls v v v snd close rcv cls send cls open snd cls data wait rcv close send cls cls v close close send cls cls wait send cls v v v rfnm wait abort cls v rfnm send cls cls closed send cls accept close figure connection state diagram newkirk et al page rfc prototypical implementation of ncp june viii algorithms for the input interpreter the following is a concise description of the ncp s responses to incoming network commands cs always indicates connection state note close is a system call executed by the local user process and cls is a network command nop discard rfc rts or str if no entry exists create one with status pending call and queue the message if cs listening then queue the entry enter the rfc rcvd state and inform the user of the request if cs rfc sent but the new rfc does not match the request refuse the rfc in all other cases check the rfc for a match if none exists queue the rfc if the rfc matches then if cs rfc sent we enter the open state cs close wait the rfc is ignored otherwise the request is illegal in all states which indicate it has already been received these states are in any case if processing the rfc causes an overflow condition resources are exhausted refuse the connection send a cls cls the pending call queue is searched if the cls doesn t match the current request but does match some other request then delete that request and issue a cls if there is no match the cls is ignored if the cls matches the current request and cs pending then delete the current request if the request queue is empty delete the entry otherwise leave the entry alone newkirk et al page rfc prototypical implementation of ncp june rfc rcvd issue a cls and enter the abort state abort ignore rfc sent issue a cls if the pending call queue is empty delete the entry else enter the pending state open if we are on the receive side response is identical to the response for rfc sent if we are on the send side clear the data queue and if a rfnm is still pending enter the rfnm wait state otherwise response is identical to the response for rfc sent cls wait issue a cls and if the pending call queue is empty delete the entry otherwise cs pending data wait clear the data queue and enter the rfnm wait state a matching cls cannot occur in the closed or listening states err errors are queued for later attention by system programmers and are considered to be a system error in the host that originated the exchange not associated with any state eco the op code is changed to erp and retransmitted not associated with any state erp upon receipt of an erp the system passes the text of the command back to the process which issued the eco inr ins these commands are enabled only in the open state upon receiving an interrupt the system causes an event to be sent to the associated process an interrupt is ignored in the cls wait data wait and rfnm wait states in any other state it is an error newkirk et al page rfc prototypical implementation of ncp june all allocate is valid only in the open state and may be sent only to a send socket the ncp increments the their size field in the associated rendezvous table entry by the size specified in the allocate command in the cls wait and data wait states this command is ignored in any other state it is an error data rfnm if in the open state mark the flow control status field in the appropriate rendezvous table entry as rfnm recvd and send more data if required if in the data wait state maintenance the flow control status if the data queue is empty issue a cls and enter the cls wait state otherwise transmit the next message if in the rfnm wait state maintenance the flow control status and issue a cls if the pending call queue is empty delete the rendezvous table entry otherwise cs pending a data rfnm is an error in all other states ix algorithms for the system call interpreter each system call is discussed giving the state changes it may effect connect if there is no entry create one issue an rfc and enter the rfc sent state if cs pending search the queue and reject all non matching requests if no match is found issue an rfc and enter the rfc sent state if a match is found issue an rfc and enter the open state transmission can commence as soon as buffer space has been allocated in any other state this command is illegal listen if an entry doesn t exist create one and enter the listening state newkirk et al page rfc prototypical implementation of ncp june if cs pending inform the user and enter the rfc rcvd state in any other state this command is illegal accept if cs rfc rcvd then issue an rfc and enter the open state data transmission can occur as soon as buffer space is allocated if cs abort inform the user of the premature termination of the connection if the pending call queue is empty delete the entry otherwise enter the pending state this command cannot be legally executed in any other state close if cs listening then delete the entry rfc rcvd then issue a cls and enter the cls wait state abort inform the user of the premature termination of the connection if the pending call queue is empty delete the entry otherwise enter the pending state rfc sent then issue a cls and enter the cls wait state open if we are on the send side and the data queue is not empty or if a data rfnm is still outstanding enter the data wait state otherwise issue a cls and enter the cls wait state cls wait issuing a close in this state is a user error data wait issuing a close in this state is also an illegal sequence rfnm wait ignore the close a valid close cannot be issued if an entry does not exist or if a socket is in the pending state this rfc was put into machine readable form for entry into the online rfc archives by anthony anderberg newkirk et al page 