 vint cerf ucla eric harslem rand rfc john heafner rand nic category d bob metcalfe mit updates none obsoletes none jim white ucsb the data reconfiguration service compiler interpreter implementation notes i new features of the language the meaning of s e l is only find an arbitrary number of ebcdic characters and store them in identifier s this descriptor is terminated only by an invalid ebcdic or by exceeding maximum permissible character count the assignment s t causes all attributes of identifier t to be given to s i e length type and contents s t x concatenates x onto the right hand side of t and stores the result in s if t and x are binary the resulting value has a length equal to the sum l t l x t x joins l x and v x as a built in identifier function t x type of identifier x l x length of contents of x v x contents of x converted to binary decimal binary is presently the only transformation new types ed and ad are ebcdic and ascii encoded decimal respectively these have been added to complement the v x function new type sb has been added as signed binary type b is a logical binary string the syntactic notation for return from a form has been changed see new syntax page data reconfiguration service rfc ii new syntax form rule form rule label inputstream outputstream label integer null inputstream terms null terms term terms term outputstream terms null term identifier identifier descriptor descriptor comparator identifier descriptor replicationexpr datatype valueexpr lengthexpr control comparator concatexpr connective concatexpr control identifier concatexpr control replicationexpr arithmetricexpr null datatype b o x e a ed ad sb t identifier valueexpr concatexpr null lengthexpr arithmeticexpr null connective le lt gt ge eq ne concatexpr value concatexpr value value literal arithmeticexpr arithmeticexpr primary arithmeticexpr operator primary primary identifier l identifier v identifier integer operator literal literaltype string literaltype b x e a ed ad sb string control options null options sfur arithmeticexpr sfur arithmeticexpr sfur arithmeticexpr sfur s f u sr fr ur page data reconfiguration service rfc iii the form interpreter interpreter overview the interpreter is a simple minded machine having the virtue of helping the compiler writer by providing a rather powerful instruction set for hard to compile operations figure shows the machine configuration inputstream outputstream cpu storage instruction sequence label table literal identifier pool variable length string area fig form interpreter page data reconfiguration service rfc the cpu is a box full of miscellaneous parts the most important being the arithmetic logic unit and the instruction decoding unit the cpu also maintains a collection of state registers to keep track of what it is doing figure shows the rough layout instruction instruction counter register v operation code decoding run time stack operands v instruction interpreter routines v arithmetic logic unit initial input ptr output pointer current input ptr true false flag page data reconfiguration service rfc fig the central processor the cpu is a stack machine driven by a polish postfix instruction sequence operands placed on the run time stack are used for arithmetic expression evaluation and for parameter passing between the interpreter and the built in functions the current input pointer and the output pointer keep track of the two data streams two input pointers are needed because of the backup requirement in the event of rule failure all of these pointers are bit pointers into the two streams various implementations of the run time stack are independent of the interpretation of the drs machine s instruction set it is suggested that the stack will contain instruction operands from the instruction stream the format of a compiled instruction sequence for a form is shown in fig bits length n in bytes compiled bit n instructions fig compiled instruction sequence format page data reconfiguration service rfc the format of the compiled label table is shown in fig bits length n in bytes numeric value of byte offset statement number in inst seq n v bits fig compiled label table page data reconfiguration service rfc literals and identifiers are compiled as shown in fig length n length n in bytes in bytes type bit length byte offset n identifiers literals are byte aligned literals m legend type undefined b binary octal x hexadecimal e ebcdic a ascii ed ebcdic encoded decimal ad ascii encoded decimal sb signed binary two s complement fig compiled literals and identifiers page data reconfiguration service rfc types b x ad ed and sb point to bit word aligned data shown below word aligned t l bit right justified types e and a point to byte aligned symbol streams as shown below byte aligned l t l page data reconfiguration service rfc instruction format since literals and identifiers will be stored in the same data area more than literals plus identifiers might be encountered so more than bits are needed to reference literal id pool furthermore such references must be distinguished from operators in the instruction stream so a bit instruction will be used as shown below v ld literal or identifier reference bit positive integer ic bit two s complement integer constant op operator ad address bit positive integer arb indefinite replication factor null missing attribute of term the operation code decoder picks up types and and deposits them on top of the stack tos ld is an index into the literal identifier table and ad is an index into the instruction sequence the decoder examines op elements further op binary operator unary operator special operator page data reconfiguration service rfc binary operators let the tos contain y and the next level x the binary operators compute x y popping both x y from stack and put the result back on top of the stack tos tos y x y e g x y x binary operator encoding v integer integer integer x integer or no remainder concatenate all binary operations except concatenate expect the top two elements on the stack to describe type b x or sb the result is always a bit type b element the concatenate operator fails unless both types are identical for example as suggested above the stack really contains instruction operands that describe data for convenience in illustrations the data rather than their descriptors are shown on the stack page data reconfiguration service rfc type l value t l v tos b b tos b before operation after operation tos a de a abcde tos a abc before operation after operation no binary operator has any effect on the true false flag unary operators v integer minus v load identifier evaluated contents after dec binary conversion length field type field label table reference page data reconfiguration service rfc for the unary minus operator the data described by the top of the stack is replaced with its s complement the form fails if the tos type is not sb b or x the load identifier expects the tos to describe an index into the literal identifier pool that is an ld instruction the tos described data is replaced by bit type b values the operation fails if the contents cannot be converted from encoded decimal to binary b and x types are treated as unsigned integers sb is treated as s complement the label table reference operator expects a bit type b value described by tos and searches for this label in the label table if found the tos described data is replaced by the relative address in the instruction sequence of the label in the form of an ad instruction if not found the form fails no unary operator has any effect on the true false flag special operators v store tos return v branch true false unconditional compare eq le ge ne lt gt move input ptr store current into initial store initial into current input call no compare compare output call page data reconfiguration service rfc store tos the tos describes an index into the id table and the next lower element in the stack describes a value to be stored after execution both elements are popped off the stack return the tos describes a value to be returned to the routine which initiated the form machine the actual mechanism will be implementation dependent but the form machine will relin quish control after this instruction completes execution branch the tos describes an index into the instruction sequence to be used as the new instruction counter ic if the branch conditions are satisfied the branch instruction checks the state of the true false flag register and either increments the ic by or replaces it with the tos described element in any case the tos is popped compare the compare operator takes the two elements described by the two top stack entries and compares them eq lt etc if n is at the top of the stack and m is just below then m xx n is performed and the true false flag is set accordingly for xx eq or ne we must have identical type length and content for equality to hold the other boolean comparators will not be attempted if types are different i e form fails but for same types b x cause binary justified compares and a e ad ed cause left justified string compares with the shorter string padded with blanks move input pointer this operator no operands replaces the current input pointer with the initial input pointer back up or the initial input pointer with the current one entry to rule input call this is the most complex operator thus far encountered it requires four operands from the run time stack page data reconfiguration service rfc tos binary or null length to find ld to literal or null value literal binary code input data type binary arbitrary or null replication count the input call operator can be invoked with the no compare flag set in which case the value expression parameter is ignored and only the input type and length expressions are used in this case the input routine tries to find in the input stream as many characters of the required type bits digits etc as needed to fill the length expression requirement if successful the true false flag is set true the stack is popped to remove the input parameters and the string obtained is described by the tos if the input stream cannot be matched then the parameters are popped off the stack and the true false flag is set false if the compare flag is set the input stream must be searched for the value expression however we must take some care here to be sure we know what to look for there are several cases a the length expression parameter is greater than the length of the value expression but the type of input de sired is the same as the value expression type for b and x types right justify value expression in length expression field sign bit is extended left if type bs if type a e ad or ed pad on the right with blanks b same as a but length is too small b and x type strings are truncated on the left a e ad and ed are truncated on the right c the type of the value expression and the type parameter differ this case is deferred for discussion and pre sently is considered an error causing form failure if the input string matches then the true false flag is set true the parameters are popped from the stack and the resulting string is described by the tos otherwise the false flag is set and the parameters are popped when a successful match is found the input subroutine always advances the current input pointer by the appropriate amount since we are dealing at the bit level this pointer must be maintained as a bit pointer page data reconfiguration service rfc output call this routine utilizes the same parameters as the input call but operates on the output stream the true false flag is not distributed by this operator as for input there are four parameters on top of the stack the length expression value the value expression value the desired output type and the replication expression value when there is a mis match between the output type and the value expression type a conversion must take place the value expression is trans formed into the desired output type and fitted into the field length specified by the length expression truncation and padding rules a character character a e ad ed a e ad ed conversion is left justified and truncated or padded with blanks on the right b character numeric and numeric character conversion is right justified and truncated or padded on the left with zeros beware two s complement numbers may be bollixed by this c numeric character conversion is right justified and left padded with blanks or left truncated as for the unary operators a numeric bit string is treated as unsigned except sb which is treated as two s complement thus we have ed x ff e ed x e but ed sb e if the output routine is able to perform the desired action it advances the output stream pointer and pops all parameters from the run time stack page data reconfiguration service rfc v instruction set it id ref ld literal or identifier reference tos int const ic small s comp integer constant tos address ad address tos null parameter null missing term attribute add add tos x y x y tos subtract sub tos x y x y tos multiply mul tos x y x y tos divide div tos x y x y tos concatenate con tos x y x y tos unary minus unin tos x x tos load id value liv tos ld x v ld x tos load id length lil tos ld x v ld x tos load id type lit tos ld x v ld x tos look up label lvl tos x ad x tos sto sto tos x y y x return ret tos x return to caller with x branch true bt tos ad x ad x instr counter branch false bf tos ad x ad x instr counter branch bu tos ad x ad x instr counter compare equal ceq tos x y y eq x true false flag compare not equal cne tos x y y ne x t ff compare cle tos x y y le x t ff call output out tos r t v l r t v l output call input in inc compare tos r t v l r t v l tos inn no compare current initial scip cip iip store current input ptr initial ip initial current sicp iip cip store initial input ptr cip page data reconfiguration service rfc vi example compilation form source generated polish instruction sequence addr instr comments numb sicp rule prelude ic ld reference to numb sto store in numb scip rule postlude cc e fr sicp rule prelude null no replication expression ic type ebcdic null no value expression ic length inn input call with no compare ad bt skip return if inn succeeds ic return code ret return to caller if failed ld reference to cc sto store input data in cc line e null no replication expression fr ic type is ebcdic null no value expression ic length inn input with no compare ad bt skip return if ok ic return code ret return to caller if failed ld reference to line sto store input in line cc scip successful input null no replication factor ld reference to cc lit type of cc ld reference to value of cc ld cc again lil length of cc out output cc ed numb null no replication ic type is ed ld reference to value of numb ic length of output field out output numb as ebcdic dec e e null no replication ic type is ebcdic page data reconfiguration service rfc ld reference to e ic length to output out output the period e line null no replication ic type is ebcdic ld reference to line ic length to output out put out contents of line numb numb ld reference to numb u ic amount to add add add to numb ld reference to numb sto store back into numb ad place to go b unconditional branch back literal identifier table numb cc line e label table label offset this rfc was put into machine readable form for entry into the online rfc archives by simone demmel page 