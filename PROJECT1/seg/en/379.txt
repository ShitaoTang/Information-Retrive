network working group rfc jeff rulifson june l del del jfr dsn lsp and not sp dual transmission abstract the decode encode language del is a machine independent language tailored to two specific computer network tasks accepting input codes from interactive consoles giving immediate feedback and packing the resulting information into message packets for network transmissin and accepting message packets from another computer unpacking them building trees of display information and sending other information to the user at his interactive station this is a working document for the evolution of the del language comments should be made through jeff rulifson at sri forward the initial arpa network working group met at sri on october it was generally agreed beforehand that the runmning of interactive programs across the network was the first problem that would be faced this group already in agreement about the underlaying notions of a del like approach set down some terminology expectations for del programs and lists of proposed semantic capability at the meeting were andrews baray carr crocker rulifson and stoughton a second round of meetings was then held in a piecemeal way crocker meet with rulifson at sri on november this resulted in the incorporation of formal co routines and stoughton meet with rulifson at sri on decembeer it was decided to meet again as a group probably at utah in late january the first public release of this paper was at the bbn net meeting in cambridge on february net standard translators nst the nst library is the set of programs necessary to mesh efficiently with the code compiled at the user sites from the del programs it receives the nst del approach to net interactive system communication is intended to operate over a broad spectrum the lowest level of nst del usage is direct transmission to the server host information in the same format that user programs would receive at the user host in this mode the nst defaults to inaction the del program does not receive universal hardware representation input but input in the normal fashion for the user host and the del program becomes merely a message builder and sender a more intermediate use of nst del is to have echo tables for a tty at the user host in this mode the del program would run a full duplex tty for the user it would echo characters translate them to the character set of the server host pack the translated characters in messages and on appropriate break characters send the messages when messages come from the server host the del program would translate them to the user host character set and print them on his tty a more ambitious task for del is the operation of large display oriented systems from remote consoles over the net large interactive systems usually offer a lot of feedback to the user the unusual nature of the feedback make it impossible to model with echo table and thus a user program must be activated in a tss each time a button state is changed this puts an unnecessarily large load on a tss and if the system is being run through the net it could easily load two systems to avoid this double overloading of tss a del program will run on the user host it will handle all the immediate feedback much like a complicated echo table at appropriate button pushes message will be sent to the server host and display updates received in return one of the more difficult and often neglected problems is the effective simulation of one nonstandard console on another non standard console we attempt to offer a means of solving this problem through the co routine structure of del programs for the complicated interactive systems part of the del programs will be constructed by the server host programmers interfaces between this program and the input stream may easily be inserted by programmers at the user host site universal hardware representation to minimize the number of translators needed to map any facility s user codes to any other facility there is a universal hardware representation this is simply a way of talking in general terms about all the hardware devices at all the interactive display stations in the initial network for example a display is thought of as being a square the mid point has coordinates the range is to on both axes a point may now be specified to any accuracy regardless of the particular number of density of rastor points on a display the representation is discussed in the semantic explanations accompanying the formal description of del introduction to the network standard translator nst suppose that a user at a remote site say utah is entered in the ahi system and wants to run nls the first step is to enter nls in the normal way at that time the utah system will request a symbolic program from nls rep this program is written in del it is called the nls remote encode program rep the program accepts input in the universal hardware representation and translates it to a form usable by nls it may pack characters in a buffer also do some local feedback when the program is first received at utah it is compiled and loaded to be run in conjunction with a standard library all input from the utah console first goes to the nls nep it is processed parsed blocked translated etc when nep receives a character appropriate to its state it may finally initiate transfers to the the bits transferred are in a form acceptable to the and maybe in a standard form so that the nlsw need not differentiate between utah and other net users advantages of nst after each node has implemented the library part of the nst it need only write one program for each subsystem namely the symbolic file it sends to each user that maps the net hardware representation into its own special bit formats this is the minimum programming that can be expected if console is used to its fullest extent since the nst which runs the encode translation is coded at the user site it can take advantage of hardware at its consoles to the fullest extent it can also add or remove hardware features without requiring new or different translation tables from the host local users are also kept up to date on any changes in the system offered at the host site as new features are added the host programmers change the symbolic encode program when this new program is compiled and used at the user site the new features are automatically included the advantages of having the encode translation programs transferred symbolically should be obvious each site can translate any way it sees fit thus machine code for each site can be produced to fit that site faster run times and greater code density will be the result moreover extra symbolic programs coded at the user site may be easily interfaced between the user s monitor system and the del program from the host machine this should ease the problem of console extension e g accommodating unusual keys and buttons without loss of the flexibility needed for man machine interaction it is expected that when there is matching hardware the symbolic programs will take this into account and avoid any unnecessary computing this is immediately possible through the code translation constructs of del it may someday be possible through program composition when crocker tells us how ahi nls user console communication an example block diagram the right side of the picture represents functions done at the user s main computer the left side represents those done at the host computer each label in the picture corresponds to a statement with the same name there are four trails associated with this picture the first links in a forward direction the labels which are concerned only with network information the second links the total information flow again in a forward direction the last two are equivalent to the first two but in a backward direction they may be set with pointers t through t respectively tif or i nif nif encode encode maps the semi raw input bits into an input stream in a form suited to the serving host subsystem which will process the input nif hrt tif net mode nif urt tif imp ctrl tif urt nif d ctrl tif prgm ctrl nif display tif dctrl sum sum sum sum sum empty the conjunct construct is rigged in such a way that a conjunct which is not a sum need not have a value and may be evaluated using jumps in the code reference to the conjunct is made only in places where a logical decision is called for e g if and while statements we hope that most compilers will be smart enough to skip unnecessary evaluations at run time i e a conjunct in which the left part is false or a disjunct with the left part true need not have the corresponding right part evaluated arithmetic expression syntax statement conditional unconditional unconditional loopst cases cibtrikst uist treest block null exp conditional if conjunct then unconditional else conditional empty block begin exp exp end an expressions may be a statement in conditional statements the else part is optional while in expressions it is mandatory this is a side effect of the way the left part of the syntax rules are ordered semi tree manipulation and testing syntax treest setpntr insertpntr deletepntr setpntr set pointer pntrname to pntrexp pntrexp direction pntrexp pntrname insertpntr insert pntrexp as left right brother first last daughter of pntrexp direction up down forward backward head tail plantree replace pntrname with pntrexp deletepntr delete pntrname tree tree tree nodename nodename nodename terminal tree terminal treename buffername point ername treename id treedecl pointer id tree id extra parentheses in tree building results in linear subcategorization just as in lisp flow and control controlst gost subst loopstr casest go to statements gost go to labelv id assignlabel assign id to labelv subroutines subst callst returnst cortnout callst call procname exp emptyu returnst return exp empty cortnout stuff exp in pipename cortnin fetch pipename fetch is a builtin function whose value is computed by envoking the named co routine loop statements syntax loopst whilest untilst forst whilest while conjunct do statement untilst until conjunct do statement forst for integerv exp by exp empty to exp do statements the value of while and until statements is defined to be false and true or and non zero respectively for statements evaluate their initial exp by part and to part once at initialization time the running index of for statements is not available for change within the loop it may only be read if some compilers can take advantage of this say put it in a register all the better the increment and the to bound will both be rounded to integers during the initialization case statements syntax casest ithcasest condcasest ithcasest ithcase exp of begin statement statement end condcasest case exp of begin condcs condcs otherwise statement end condcs conjunct statement the value of a case statement is the value of the last case executed extra statements null null i o statements iost messagest dspyst messages syntax messagest buildmes demand buildmest startmes appendmes sendmes startmes start message appendmes append message byute exp sendmes send message demandmes demand message mesinfo get message byte message length message empty mesdecl message bytes are byn bits long display buffers syntax dspyst startbuffer bufappend estab startbuffer start buffer bufappend append bufstuff bufstuff bufstuff parameters dspyparm dspyparm character exp string strilng vector from exp exp empty to exp exp position onoff empty beam to exp exp curve dspyparm f intensity to exp character width to exp blink onoff italics onff onoff on off estab establish buffername logical screen the screen is taken to be a square the coordinates are normalized from to on both axes associated with the screen is a position register called preg the register is a triple where x and y specify a point on the screen and r is a rotation in radians counter clockwise from the x axis the intensity called intensity is a real number in the range from to is black is as light as your display can go and numbers in between specify the relative log of the intensity difference character frame size blink bit buffer building the terminal nodes of semi trees are either semi tree names or display buffers a display buffer is a series of logical entities called bufstuff when the buffer is initilized it is empty if no parameters are initially appended those in effect at the end of the display of the last node in the semi tree will be in effect for the display of this node as the buffer is built the logical entities are added to it when it is established as a buffername the buffer is closed and further appends are prohibited it is only a buffername has been established that it may be used in a tree building statement logical input devices wand joy stick keyboard buttons light pens mice audio output devices end sample programs program to run display and keyboard as tty to run nls input part display part demand message while length o do ithcase getbyte of begin ithcase getbyte of file area uipdate begin literal area message area name area bug sequence specs filter specs format specs command feedback line filer area date time echo register begin del control distribution list steve carr department of computer science university of utah salt lake city utah phone x steve crocker boelter hall university of california los angeles california phone jeff rulifson stanford research institute ravenswood menlo park california phone x ron stoughton computer research laboratory university of california santa barbara california phone mehmet baray corey hall university of california berkeley california phone 