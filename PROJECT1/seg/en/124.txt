 network working group w naylor request for comments j wong nic c kline categories d d j postel obsoletes none ucla nmc updates may regarding proferred official icp we should like to comment on a race condition discovered in the icp as proposed in nwg rfc the problem arises when the server attempts to initiate a second connection to the user s receive socket and the first connection is not yet closed using a similar notation to that of nwg rfc the following table illustrates the sequence of events in the proferred and proposed icp the last two columns indicate which actions must be completed before the current action may be initiated user and server are third level programs and uncp and sncp are the users ncp and servers ncp respectively allocates have not been included since they add nothing to the argument required predecessors reference action initiator proferred proposed listen l server init u l user rts u l l uncp str l u sncp and and send l s server send l s sncp receive l s uncp receive u s user close l server cls l u sncp and and close u user not used cls u l uncp page nwg regarding proferred official icp rfc required predecessors reference action initiator proferred proposed init s u b server u rts s u l sncp init s u b server and s str s u b sncp s init u s b user u str u s b uncp u init u s b user s rts u s l uncp note that in the proferred order column can occur before in which case uncp would find socket u in use and probably return a cls u s the server would probably then assume the user was finished with the conversation the above problem is resolved by eliminating the close from one side and causing that side to wait for the cls from the other side before doing an init we propose that eliminating the user s close u is the best solution the user ncp must of course return a cls in response to the cls sent by the server ncp the server s close l leads more quickly to the reuse of socket l thus the serving of another user page nwg regarding proferred official icp rfc to clarify the above discussion which may seem confusing at first glance let us demonstrate the problem in the language of rfc server user s listen l u init u l s wait for match u s send l s u receive u s s close l u close u s init s u b u init u s b u u s init s u b u init u s b s s notice that since server and user are independent probably in different hosts server could execute s before user executes u and could receive an error back from user s ncp that socket u is busy similarly user could execute u before server executes s and could receive an error back from his own ncp that socket u is not yet closed assuming an implementation where sockets are kept busy until a cls match various modifications could be made to icp to solve this problem we propose the following icp page nwg regarding proferred official icp rfc server user listen l init u l wait for match send l s receive u s close l wait for cls init s u b init u s b u u wait for match init u s b s init s u b s this icp assumes the following the user can inquire or is notified of the fact that one of his connections has been closed the server can inquire or is notified that a connection for which he has done an init or listen is now open both of the above seem basic to any ncp user interface this race condition problem would not exist had the dynamic reconnection features of rfc been included in the ncp protocol and had dynamic reconnection been used in this icp this rfc was put into machine readable form for entry into the online rfc archives by walter pienciak page 