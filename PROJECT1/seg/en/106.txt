 network working group r kalin request for comments mit july a simplified ncp protocol abstract this rfc defines a new ncp protocol that is simple enough to be implemented on a very small computer yet can be extended for efficient operation on large timesharing machines because worst case storage requirements can be predicted a conservative implementation can be freed of complicated resource allocation and storage control procedures a general error recovery procedure is also defined overview and rational the central premise of this proposal is an insistence that all user to user connections be bi directional for those familiar with communication theory this appears most reasonable all communication requires a cyclical flow of information to deny a simple association between a message and its reply makes protocol unnecessarily complicated and turns simple mechanisms of flow control into nightmares it is proposed that a bi directional connection or duplex link be identified by a pair of socket numbers one for each end this is half the number presently required associated with the connection are some number of crates or message containers these crates travel back and forth over the link carrying network messages from one side to the other buffers are allocated at each end of the link to hold crates and the messages that they carry worst case buffer requirements are equal to the number of crates in circulation or the capacity of the link details a message buffer has four states which follow one another cyclically they are empty filled with a message laden crate to be unloaded filled with an empty crate and filled with a message laden crate to be sent kalin page rfc a simplified ncp protocol july normally state transitions correspond to message arrival message removal message insertion and message transmission for a process to be an ncp it must be able to make initial contact with foreign hosts via the control link and if necessary delete user to user links left over from the previous system incarnation be able to create user to user links be able to interface users with these links be able to delete user to user links the first of the four functions shall not be discussed here except to point out that it contains critical races that can not be resolved without making assumptions about maximum message propagation delays since within the arpa network bounds on message turnaround time do not exist the approach chosen must necessarily be tender the other three functions are discussed first from the viewpoint of one interested in implementing a minimal ncp then extensions and improvements are proposed that are suitable for larger machines any ncp must be capable of creating a duplex link between a local user process and a remote one the current protocol accomplishes this by queuing a potentially unbounded number of rfc s and waiting for the user to examine the queue to determine with whom he wishes to talk there is no guarantee that the user will ever look at the queue and there is no way to limit the size of the queue the overflow error message suggested fails in the respect because it admits that the rfc will only be sent again the picture need not be this bleak the following network conversation demonstrates how connections can be made without using queues or relying on user process attention suppose that a local user process and a remote user process wish to establish a new connection the remote process asks its ncp to listen for a connection request and gives it the socket identifier for its end optionally it can give both socket identifiers the user process at the local end asks its ncp to send a request for a duplex link rfdl it specifies both socket identifiers of the proposed link the local ncp sends a rfdl over the control link with the following format rfdl kalin page rfc a simplified ncp protocol july the third argument is normally supplied by the local ncp and indicates the maximum number of buffers the ncp will consider allocating to this duplex link if buffers are in user storage the count may be given by the user in a call made to the ncp the rfdl is received at the remote host and the remote ncp compares and against the socket identifiers supplied by unmatched listens issued to it for listens in which just a single identifier was given only must match if both socket identifiers were given they both must match if a match is found an acknowledgement message with the following format is sent back by the ncp acdl the parameter is equal to the smaller of as specified in the rfdl and the number of message buffers agreeable to the remote ncp if no match is found the error message returned is an acdl in which equals zero note that the rfdl mechanism is similar to a rfc mechanism in which the bound on queue size is one and connection acceptance is done entirely by the ncp the two varieties of a listen correspond to two modes of channel operation the single parameter variety as typified by a login process is to be used by programs that will talk with anyone who happens to dial their number screening of contacts for appropriateness is left to the user process the double parameter listen is used by user programs who know with whom they will communicate and do not wish to be bothered by random rfdl s from other sources given the way in which socket name space is partitioned it is impossible to get a matching rfdl from any process but the one intended message buffers for the connection are allocated in the remote host before it sends the acdl and in the local host at the time the acdl is received the number of buffers at each end is equal to the parameter in the acdl the state of all remote buffers is empty and of all local buffers filled with empty crate after buffers are allocated the local user process is notified that it is able to start sending messages the type of interface presented by the ncp between the user process and the newly created duplex link is a decision local to that host a simple but complete interface would provide two calls to be made to the ncp getmessage would return the next message from the link complete with marking text and padding putmessage would take a kalin page rfc a simplified ncp protocol july message marking and text only and buffer it for transmission the obvious logical errors would be reported we suggest that message alignment be left to the user on most machines it is a simple but time consuming operation if done in the ncp there is no guarantee that the user will not have to readjust it himself it is usually not possible to know a priori whether the text portion should be right adjusted to a word boundary left adjusted to a word boundary aligned to the end of the last message or fragmented in some exotic way within this protocol message boundaries are used to provide storage allocation information if not required by the user this information can be forgotten and the user interface can be made to appear as a bit stream though welcomed by purists such a strategy may produce complications when attempting to synchronize both ends of a link links are deleted by removing empty crates from them and reclaiming the buffers allocated to the crates removed only buffers with crates in can be reclaimed empty buffers must remain available to receive messages that may arrive when no crates are left no buffers remain and the socket identifiers can be forgotten when empty crates are removed a decrement size message is sent to the foreign ncp to allow it to reduce its buffer allocation dec a reply is solicited from the foreign ncp to affirm the deletions or to complain of an error possible errors include no such link and impossible number of buffers dropped the option to close a link can be given to a user process by providing either of two system calls nomoreoutput declares that no more messages will be sent by the local user process all local buffers for the link that contain empty crates are reclaimed by the ncp dec messages are sent to the foreign ncp as crates are emptied via getmessage calls their buffers are reclaimed too as an alternative the call killmessage can be implemented this call can be used in place of a putmessage instead of filling an empty crate with a message to be sent killmessage will cause the crate to be reclaimed and a dec control message sent in situations where the user process has died or for some other reason can not close the link more drastic measures must be taken for these situations the abend control message is defined abend kalin page rfc a simplified ncp protocol july after sending an abend the issuing ncp starts to close the link all buffers containing input are destroyed a dec is issued for these and the previously empty buffers if messages arrive on the link they are destroyed and a dec is issued any abend received for the link is ignored when the remote ncp receives the abend it stops sending messages over the link and refuses new messages from the user process at its end empty buffers are reclaimed pending output messages are destroyed and their buffers reclaimed input messages are fed to the user process as long as it will accept them buffers are reclaimed as input is accepted dec s are issued to cover all buffers reclaimed when the user process will take no more input input messages are destroyed and their buffers reclaimed eventually all buffers will be reclaimed at both ends of the link at such time the connection can be considered closed and the socket numbers used can be reassigned without ambiguity under this proposed protocol the above four functions constitute all that must be part of a network ncp if buffers are allocated only when free ones exist there can be no overflow errors nor is there any need to place further constraints on message flow for any user message that arrives buffer room is guaranteed all control messages can be processed without requiring additional storage to be allocated attempts by a user process to issue too many listens can be thwarted by local control procedures inefficiencies in storage will result when the number of outstanding connections gets large one price of coding simplicity is a fifty percent utilization of buffer space on large hosts it may prove advantageous to implement some of the following ncp extensions with more complicated flow control procedures it becomes possible for an ncp to allocate more buffer space than actually exists and still not to get into trouble other extensions provide message compression improved throughput and user transparent error recovery because some extensions require the cooperation of foreign hosts and assume that they have implemented more than the minimal ncp it is proposed that an inquiry control message be used to find out what extensions the foreign host has implemented the response to an inq will be a control message defining a host profile if an undefined error message is returned the foreign host is assumed to have only a minimal ncp a simple extension is to define a control message that will replace user rfnm s a user rfnm is a null text message sent for example as a reply when a file is transferred via a duplex link they are inefficient since they tie up an entry in the imp s link assignment kalin page rfc a simplified ncp protocol july table and degrade network throughput a more efficient solution is to send a special message over the control link in this way one short message can replace several user messages urfnm because the control link is concurrent with the return side of the user link urfnm s can not be substituted for user rfnm s when there are other messages to be sent on the return link otherwise ordering will be lost and with it user transparency throughput can also be increased with a mechanism to add additional crates on a duplex link this might be at user instigation or be a decision of the ncp inc the foreign host replies to an increase request by returning an incr incr if the foreign ncp is unable to meet the additional buffer demand will be less than and possibly zero the initial state of all local buffers added is filled with empty crate and of all foreign buffers empty the spare argument in the rfdl and acdl could be used to declare the maximum sized message that will actually be sent in that direction a perceptive ncp could observe this information and allocate smaller buffers a lesser ncp could ignore it and always assume maximum length messages for example if the field were zero then only user rfnm s would be sent a smart ncp would allocate no storage at all if the ncp retains a copy of each user message sent over the network until a reply is returned an automatic error recovery procedure can be implemented because the capacity of the link is always known an ncp can determine whether there are messages in transit this is done by first sending a stop message to the foreign ncp stop the stop message tells the foreign ncp to temporarily stop transmitting messages over the selected link unlike cease on link there is no guarantee as to how many messages will be sent before the stop takes effect the local ncp then sends a link inquiry message linq kalin page rfc a simplified ncp protocol july the reply gives the number of crates at the foreign end of the link the linq message is repeated until this number plus the number of local crates equals the capacity of the link at this time no messages are in transit and the two ends of the link have been synchronized messages can now be identified relative to the synchronization point thus the local ncp can send a control message asking for example that the third to last message be retransmitted the foreign ncp is able to identify which message this is and to retransmit it once all errors have been recovered a start control message similar in format to the stop is sent to the foreign ncp and normal operation continues the entire recovery procedure can be transparent to both user processes it is expected that the larger hosts will not adhere strictly to the worst case storage allocation requirements rather they will allocate more buffers than they have and reply on statistics to keep them out of trouble most of the time such conduct is perfectly permissible as long as it is transparent to foreign hosts the protocol allows an ncp to lie about storage allocation as long as he is not caught in situations where detection appears imminent some of the following control mechanisms will need to be applied they are listed in increasing order of power a do not send out any user rfnm s or other short messages there is a good chance that they will be replaced by longer messages that will strain buffer capacity even more b try not to accept any new messages from the imp block local processes attempting to issue messages c issue dec s to free up buffer space do not allocate more than one buffer to rfdl s and refuse inc s d fake errors in messages waiting for local user action do this only if the host that sent it has implemented error recovery this will free buffer space and allow you to recover later this final measure is admittedly a last resort but it should be powerful enough to control any emergency it is the hope of the author that the above protocol presents an attractive alternative to that proposed by rfc and its additions although it appears at a late date it should not be more than a minor jolt to implementation efforts it is simple enough to be implemented quickly if adopted a majority of the present sites could be talking intelligently with one another by the end of the summer kalin page rfc a simplified ncp protocol july references crocker s d postel j newkirk j and kraley m official protocol proffering rfc june author s address richard kalin mit lincoln laboratory this rfc was put into machine readable form for entry into the online rfc archives by ian redfern kalin page 