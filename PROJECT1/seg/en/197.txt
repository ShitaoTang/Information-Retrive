 nwg rfc conversations with steve crocker ucla edwin w meyer jr mit project mac april both my personal opinions and those that i believe represent a consensus of the network working group at project mac are presented here the pronouns i and we are used to distinguish between these on april and thomas p skinner and i had telephone conversations with steve crocker at ucla relating to the network protocol specifically regarding our proposal in nwg rfc the following items were discussed i hope that steve will pardon me if i happen to misparaphrase him steve stated that he felt that a need for dynamic reconnection would later be recognized by the network participants however because of a lack of consensus it will not be included in the initial implementation we at project mac favor this approach of not including it initially steve supported the implementation of the int network command described in nwg rfc this command allows a process that has agreed to accept interrupts over a socket connection to be reliably interrupted by the process at the other end the interrupt causes a process to abey its current execution and execute a procedure that it has specified as the int handler the ncp does not specify the int handler that is the function of higher level protocols the int command is designed specifically for use by a third level user control and communication ucc protocol to implement a quit signal under such a protocol both the requestor and the created process agree that an int related to a specific socket connection and transmitted over the ncp control link to the created process is the standard quit signal the created process provides an int handler that implements this quit function this does not preclude a different interpretation of int by other third level protocols although many systems implement the quit as a control character in the teletype input stream systems such as ctss multics and others implement it as a ms spacing on the line we at mac think that the page nwg rfc conversations with steve crocker ucla first method is an undesirable implementation within the network while the second is impossible i put forth several reasons why and i think steve agreed a the link over which the quit character is to be transmitted may be blocked b while the interrupt is most effectively implemented within the ncp it is undesirable for the ncp to place any particular structure on the data being transmitted see discussion below this would be required if the ncp were to scan a data stream for a control character c scanning the input stream greatly reduces ncp efficiency in a subsystem where speed is critical to effective operation steve pointed out that the implementation of int as a quit should not necessarily preclude a host s interpretation of a control character in the input stream from also acting as a quit steve is opposed both to including the instance tag in the socket identifier and reserving a null field in the identifier for future definition he cited several reasons a multiple processes of a single user should be indistinguishable to a foreign process i agree with this in certain cases when processes are co ordinated in joint action but what about the case where two processes of the same user both want to independently use the network b a process wishing to connect to one of a foreign user s processes does not know the instance tag of the particular process that he wants and he can t easily find out c if an instance tag should later prove desirable it could be added with some difficulty i claim that something as fundamental as the length of a socket identifier will prove very resistant to change tom stated that perhaps the low order three bits of the user code could be reserved for later interpretation as an instance tag he doesn t think that a separate field is of great importance steve s arguments seem to have merit perhaps tom s suggestion is the way to go i am currently undecided on this matter we all steve and mac seem to agree that at the ncp level there should be no special structure imposed on the data transmitted to an ncp all data to be transmitted are bit strings of arbitrary length one page nwg rfc conversations with steve crocker ucla happy result is that the difficult question of character sets does not have to be resolved at this protocol level to include a character set specification at the ncp level would delay agreement on the protocol and make this character set more resistant to change if there is to be a standard character set we prefer ascii after all it is the prefered standard of our sponsoring organization we also agree with steve that there should be no optional echoing of messages at the ncp protocol level this is also the position of the sdc people in rfc shoshani long and landsberg also state rfc that they prefer to align messages to end on a word boundary as opposed to double padding steve agrees with us in not liking double padding in our proposal rfc we suggest that rfcs be queued only for open sockets that rfcs to inactive or connected sockets are to be automatically rejected via the cls command steve proposes that rfcs to these sockets be briefly queued if the socket remains in an unacceptable state for a specific interval after the rfc comes in it is rejected this scheme allows certain types of network command interaction involving critical races to be implementable such a scheme of limited queueing does not seem unreasonable to me steve tom and i discussed strategies for a user control and communication ucc protocol steve said that he disliked our ucc strategy rfc because it requires maintaining two full duplex connections to the requestor process and switching between them steve put forth an alternate proposal a process wishing to create a user process at a foreign host issues rfcs to sockets and belonging to the user whose process he wishes to create if these sockets are inactive the ncp automatically directs these requests to the foreign host s logger process the logger accepts connection and performs the login ritual if successful the logger creates a user process and lets go of the usurped sockets so that the created process may use them to communicate with the requestor process i note that this does not use reconnection at a network level since the logger uses sockets belonging to the ultimate user however it does involve internal reconnection tom and i objected to this because it introduces ucc protocol into the ncp level the ncp must direct all rfcs to inactive sockets and to a logger process i made a quick suggestion that perhaps our two proposals could be combined such that the requestor issues a signalling rfc to a signal socket of the ucc process the ucc page nwg rfc conversations with steve crocker ucla rejects the rfc but remembers who is calling it then tries to connect two sockets of the process to be created to the requestor s sockets and conducts the login ritual through these steve liked this and suggested that i write it up following the conversation i thought of several disadvantages to this ucc strategy a if the control sockets at a created process are limited to and there is the possibility that a rightful user may not be able to communicate with a foreign ucc because the ucc already is using those sockets to communicate with an imposter the logger will discover this and turn off the imposter but this is an aggravating security breach a malicious process could issue simultaneous multiple requests to tie up the sockets and prevent access to a rightful user a better solution is to allow any socket pair of the potential user process to act as the control path this permits the ucc to conduct simultaneous interrogations of competing requestors b a disadvantage of both crocker s and the combined ucc is that the user to be logged in is specified by supplying a socket belonging to a particular user the logger must now make the additional check that the user it is logging in actually belongs to the socket pair it is talking over this seems the reverse of the prefered process to identify a user and then determine the user code for his socket identifiers c the user may not know the socket user code of the user he wishes to log in at the foreign host after all there is no basic reason why the requestor and created processes should have the same user code so long as the requestor satisfies the foreign logger d in the combined strategy there is no way for the requestor to specify which socket user code it wants the only assumption that the ucc can make is that the requestor process wishes to log in a process having the same socket user code as itself this may not seem very important but i envision a scheme in which a local process exists to allow consoles attached to the local host to login at a foreign host without being logged in locally e the idea of allowing a process to masquerade within the network as another process even with the best of intentions by using its socket user code introduces a potentially dangerous security breach i think that it should be a basic protocol law that no process whatsoever may request or accept connections or transmit or receive data over a socket having a user code not its own this does not apply to an ncp process which has responsibility for such transmission nor does it prevent a priviliged process from closing or rejecting connections between a foreign process and another local process page nwg rfc conversations with steve crocker ucla i still think that the ucc proposal we advanced in rfc is a good workable scheme it does not require socket reconnection either expressly throughout the network or implicitly within an ncp nor do any of the objections raised above apply the only particular disadvantage i see is that it requires the requestor process to maintain and switch between two full duplex connections i don t see this as a serious hindrance i would like the comments of the network participants on this point in particular fortunately the ucc is a third level protocol the second level ncp can be specified before we reach final agreement on a ucc provided that the ncp allows implementation of a workable ucc steve expressed the thought that there need not be an initial standard ucc that there might be several uccs we at mac disagree if we are all to talk to each other and not between limited subsets of hosts within the network there must be an initial standard ucc which everybody implements steve is of course correct that there can be other experimental uccs also implemented it is theoretically possible for each host to provide multiple sets of software to allow a requestor process to communicate with the loggers at hosts implementing different uccs i don t think that it will work this way in practice each host will implement the ucc protocol that is most agreeable to it and will provide one set of software so that a requestor process can communicate only with those hosts which implement similar uccs i don t think that there is much enthusiasm at project mac for implementing a non standard ucc just so we can talk to ourselves we want to implement a single ucc supported at all installations so that we can log in to all hosts using this protocol and that users at all foreign hosts can log in to us this rfc was put into machine readable form for entry into the online rfc archives by altair petrofsky page 