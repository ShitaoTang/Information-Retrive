 network working group j postel request for comments s crocker ucla april a possible protocol plateau i introduction we have been engaged in two activities since the network meeting of march and as promised are reporting our results first we have considered the various modifications suggested from all quarters and have formed preferences about each of these in section ii we give our preferences on each issue together with our reasoning second we have tried to formalize the protocol and algorithms for the ncp we attempted to do this with very little specification of a particular implementation our attempts to date have been seriously incomplete but have led to a better understanding we include here only a brief sketch of the structure of the ncp section iii gives our assumptions about the environment of the ncp and in section iv the components of the ncp are described ii issues and preferences in this section we try to present each of the several questions which have been raised in recent nwg rfc s and in private conversations and for each issue we suggest an answer or policy in many cases good ideas are rejected because in our estimation they should be incorporated at a different level a double padding as bbn report explains the imp side of the host to imp interface concatenates a followed by zero or more s to fill out a message to an imp word boundary and yet preserve the message length furthermore the host side of the imp to host interface extends a message with s to fill out the message to a host word boundary bbn s mechanism works fine if the sending host wants to send an integral number of words or if the sending host s hardware is capable of sending partial words however in the event that postel crocker page rfc a possible protocol plateau april the sending host wants to send an irregular length message and its hardware is only capable of sending word multiple messages some additional convention is needed one of the simplest solutions is to modify the imp side of the host to imp interface so that it appends only s this would mean that the host software would have to supply the trailing bbn rejected the change because of an understandably strong bias against hardware changes it was also suggested that a five instruction patch to the imp program would remove the interface supplied but this was also rejected on the new grounds that it seemed more secure to depend only upon the host hardware to signal message end and not to depend upon the host software at all two other solutions are also available one is to have double padding whereby the sending host supplies and the network also supplies upon input a receiving host then strips the trailing the other solution is to make use of the marking marking is a string of the form inserted between the leader and the text of a message the original intent of marking was to extend the leader so that the sending host could begin its text on a word boundary it is also possible to use the marking to expand a message so that it ends on a word boundary notice that double padding could replace marking altogether by abutting the text beginning against the leader for bit machines this is convenient and marking is not while for other lengths particularly bit machines marking is much more convenient than double padding we have no strong preference partially because we can send word fragments shoshani et al in nwg rfc claim that adjusting the marking does not cause them any problems and they have a bit machine since the idea of marking has been accepted for some time we suggest that double padding not be used and that marking be used to adjust the length of a message we note that if bbn ever does remove the from the hardware padding only minimal change to host software is needed on the send side a much prettier and more expensive arrangement was suggested by w sutherland he suggested that the host imp interfaces be smart enough to strip padding or marking and might even parse the message upon input postel crocker page rfc a possible protocol plateau april b reconnection a very large population of networkers has beat upon us for including dynamic reconnection in the protocol we felt it might be of interest to relate how it came to be included after considering connections and their uses for a while we wondered how the mechanism of connections compared to existing forms of intra host interprocess communication two aspects are of interest what formalisms have been presented in the literature and what mechanisms are in use the formalisms are interesting because they lead to uniform implementations and parsimonious design the existing mechanisms are interesting because they point out which problems need solving and sometimes indicate what an appropriate formalism might be in particular we have noticed that the mechanisms for connecting a console to the logger upon dial in the mechanisms for creating a job and the mechanisms for passing a console around to various processes within a job tend to be highly idiosyncratic and distinct from all other structures and mechanisms within an operating system with respect to the literature it appears there is only one idea with several variations viz processes should share a portion of their address spaces and cooperatively wake up each other semaphores and event channels are handy extensions of wake up signals but the intent is basically the same event channels could probably function as connections but it seems not to be within their intended use in small systems the efficiency and capacity of event channels are inversely related with respect to existing implementations we note that several systems allow a process to appear to be a file to another process some systems e g the sds at sri impose a master slave relationship between two processes so connected but other systems provide for a coequal relationship e g the ai group s pdp system at mac the pdp system also has a feature whereby a superior process can surround an inferior process with a mapping from device and file names to other device and file names consoles have nearly the same semantics as files so it is quite reasonable for an inferior process to believe it is communicating with the console but in fact be communicating with another process the similarity between network connections and existing sequential interprocess connections supports our belief that network connections are probably the correct structure for postel crocker page rfc a possible protocol plateau april using the network moreover the structure is clean enough and compatible with enough machines to pass as a formalism or theory at least to the extent of the other forms of interprocess communication presented in the literature any new formalism we believe must meet at least the following two tests what outstanding problems does it solve is it closed under all operations in the case of network connections the candidates for the first are the ones given above i e all operations involving connecting a console to a job or a process also of interest are the modelling of sequential devices such as tape drives printers and card readers and the modeling of their buffering spooling symbiont systems the second question mentions closure in applying the connection formalism to the dial in and login procedures we felt the need to include some sort of switching or reconnection and an extremely mild form is presented in an sjcc paper which is also nwg rfc this mild form permits only the substitution of aen s and even then only at the time of connection establishment however it is a common experience that if an operation has a natural definition on an extended domain it eventually becomes necessary or at least desirable to extend its definition therefore we considered the following extensions switching to any other socket possibly in another host switching even after data flow has started there is even some precedent for feeling these extensions might be useful in one view of an operating system we see all available phone lines as belonging to a live process known as the logger the logger answers calls screens users and creates jobs and processes one of the features of most telephone answering equipment is that many phone lines may serve the same phone number by using a block of sequential numbers and a rotary answering system in our quest for accurate models of practical systems we wanted to be able to provide equivalent service to network users i e they should be able to call a single advertised number and get connected to the logger thus a prima facie case for switching is established postel crocker page rfc a possible protocol plateau april next we see that after the logger interrogates a prospective user it must connect the user to a newly created job data flow between the user and the logger has already commenced so flow control has to be meshed with switching if it is desired not to lose or garble data in transit with respect to inter host switching we find it easy to imagine a utility service which is distributed throughout the network and which passes connections from one socket to another without the knowledge of the user also it is similar to the more sophisticated telephone systems to standard facilities of telephone company operators and to distributed private systems these considerations led us to investigate the possibility of finding one type of reconnection which provided a basis for all known models the algorithm did not come easily probably because of inexperience with finite state automata theory but eventually we produced the algorithm presented in nwg rfc a short time later bill crowther produced an equivalent algorithm which takes an alternate approach to race conditions networkers seem to have one of two reactions either it was pretty and perhaps ipso facto useful or it was complex and again perhaps ipso facto unnecessary the latter group was far more evident to us and we were put into the defensive position of admitting that dynamic reconnection was only pretty useful for login and console passing in response to persistent criticism we have made the following change in the protocol instead of calling socket to login sockets of the form and are the input and output sockets respectively of a copy of the logger or if a job has been stared with user id u these sockets are the console sockets the protocol for login is thus to initiate a connection to and if user u is not in use a copy of the logger will respond and interrogate the caller if user id u is in use the call will be refused this modification was suggested by barry wessler recently others also suggested this change much earlier but we rejected it then the logger may demand that the caller be from the same virtual net i e the caller may have user id u in some other host or it may demand that the user supply a password matched to user postel crocker page rfc a possible protocol plateau april id u or it may demand both some systems may even choose to permit anybody to login to any user id after login aen s and remain the console aen s each system presumably has mechanisms for passing the console and these would be extended to know about aen s and for network users passing the console is thus a matter of reconnecting sockets to ports and happens within the host and without the network in conversations with meyer and skinner after nwg rfc was received they suggested a login scheme different from both meyer s and ours in section above their new scheme seemed a little better and we look forward to their next note it is generally agreed that login should be third level that is above the ncp level we are beginning to be indifferent about particular logins schemes all seem ok and none impress us greatly we suggest that several be tried it is some burden of course to modify the local login procedure but we believe it imposes no extra hardship to deal with diverse login procedures this is because the text sequences and interrupt conventions are so heterogenous that the additional burden of following say our scheme on our system and meyer s on multics is minimal we are agreed that reconnection should not be required in the initial protocol and we will offer it later as an optional and experimental tool in addition we would like to be on record as predicting that general reconnection facilities will become useful and will provide a unifying framework for currently ad hoc operating system structures c decoupling connections and links bill crowther bbn and steve wolfe ucla independently have suggested that links not be assigned to particular connections instead they suggest include the destination socket as part of the text of the message and then send messages over any unblocked link we discussed this question a little in nwg rfc and feel there is yet an argument for either case with the current emphasis on simplicity speed and small core requirements it seems more efficient to leave links and connections coupled we therefore recommend this postel crocker page rfc a possible protocol plateau april d error reporting as mentioned by j heafner and e harslem of rand it is important to treat errors which might occur a good philosophy is to guard against any input which destroys the consistency of the ncp s data base the specific formulation of the error command given by heafner and harslem in nwg rfc and by meyer in nwg rfc seems reasonable and we recommend its adoption some comments are in order however a distinction should be made between resource errors and other types of errors resource errors are just the detection of overload conditions overload conditions are well defined and valid although perhaps undesirable other types of errors reflect errant software or hardware we feel that resource errors should not be handled with error mechanisms but with mechanisms specific to the problem thus the command may be issued when there is no more room to save waiting s flow control protocol is designed solely to handle buffering overload with respect to true errors we are not certain what the value of the command is to the recipient presumably his ncp is broken and it may only aggravate the problem to bombard it with error commands we therefore recommend that error generation be optional that all errors be logged locally in a chronological file and that commands received likewise be logged in a chronological file no corrective action is specified at this time in the short time the network has been up at ucla we have become convinced that the network itself will generate very few errors we have watched the bbn staff debug and test the imp program and it seemed that most of the errors affected timing and throughput rather than validity hence most errors will probably arise from broken hosts and or buggy ncp s e status testing and reporting a valuable debugging aid is to be able to get information about what a foreign ncp thinks is happening a convenient way to do this is to permit ncp s to send status whenever they wish but to always have them do it whenever they receive a request postel crocker page rfc a possible protocol plateau april since we view this feature as primarily a debugging tool we suggest that a distinct link like be used the intent is that processing of status requests and generating of status messages should use as little of the normal machinery as possible thus we suggest that link be used to send request status and status is commands the form follows the suggestion on page of nwg rfc meyer s command is easily implemented and serves the more basic function of testing whether a foreign ncp is alive we suggest that the length of the command be variable as there seems to be no significance in this context to bits also the value of a presumably bit binary switch is unclear so we recommend a pair of commands and where is bits upon receipt of an command the ncp would echo with the command f expansion and experimentation as meyer correctly points out in nwg rfc network protocol is a layered affair three levels are apparent so far imp network protocol network control program protocol special user level or subsystem level protocol this last level should remain idiosyncratic to each host or even each user the first level is well specified by bbn and our focus here is on level we would like to keep level as neutral and simple as possible and in particular we agree that login protocol should be as much on level as possible simplicity and foresight notwithstanding there will arise occasions when the level protocol should change or be experimented with in order to provide for experimentation and change we recommend that only link numbers through be assigned to regular connections with the remaining link numbers to used experimentally we have already suggested that link be used for status requests and replies and this is in consonance with our view of the experimental aspects of that feature postel crocker page rfc a possible protocol plateau april we also recommend that control command prefixes from downward be used for experimentation these two conventions are sufficient we feel to permit convenient experimentation with new protocol among any subset of the sites we thus do not favor inclusion of ancona s suggestion in nwg rfc for a message data type code as the first eight bits of the text of a message g multiplexing ports to sockets wolfe in nwg rfc and shoshani et al in nwg rfc suggest that it should be possible to attach more than one port to a socket while all of our diagrams and prototypical system calls have shown a one to one correspondence between sockets and ports it is strictly a matter of local implementation we note that sockets form a network wide name space whose sole purpose is to interface between the idiosyncratic structures peculiar to each operating system our references to ports are intended to be suggestive only and should be ignored if no internal structures corresponds to them most systems do have such structures however so we shall continue to use them for illustration h echoing interrupts and code conversion interrupts we had been under the impression that all operating systems scanned for a reserved character from the keyboard to interpret it as an interrupt signal tom skinner and ed meyer of mit inform us that model tty s and ibm generate a long space of milliseconds which is detected by the i o channel hardware and passed to the operating system as an interrupt the long space is not a character it has no ascii code and cannot be program generated well over a year ago we considered the problem of simulating console interrupts and rejected the type command because it didn t correctly model any system we knew we now reverse our position and recommend the implementation of an interrupt system call and an control command as suggested by meyer in nwg rfc postel crocker page rfc a possible protocol plateau april two restrictions of the interrupt facility should be observed first when communicating with systems which scan for interrupt characters this feature should not be used second non console like connections probably should not have interrupts we recommend that systems follow their own conventions and if an arrives for a connection on which it shouldn t the should be discarded and optionally returned as an error echoing and code conversion we believe that each site should continue its current echoing policy and that code conversion should be done by the using process standardization in this area should await further development ancona s suggestion of a table driven front end transducer seems like the right thing but we believe that such techniques are part of a larger discussion involving higher level languages for the network i broadcast facilities heafner and harslem suggest in nwg rfc a broadcast facility i e and we do not fully understand the value of this facility and are thus disposed against it we suspect that we would understand its value better if we had more experience with os it is probably true in general that sites running os or similar systems will find less relevance in our suggestions for network protocol than sites running time sharing systems we would appreciate any cogent statement on the relationship between os and the concepts and assumptions underlying the network protocol j instance numbers meyer in nwg rfc suggests extending a socket to include an instance code which identifies the process attached to the socket we carefully arranged matters so that processes would be indistinguishable we did this with the belief that both as a formal and as a practical matter it is of concern only within a host whether a computation is performed by one or many processes thus we believe that all processes within a job should cooperate in allocating aen s if an operating system has facilities for passing a console from process to process within a job these facilities mesh nicely with the current network protocol even within reconnection protocol but instance numbers interfere with such a procedure postel crocker page rfc a possible protocol plateau april we suggest this matter be discussed fully because it relates to the basic philosophy of sockets and connections presently we recommend bit socket numbers without instance codes k aen s nobody including us is particularly happy with our name aen for the low order bits of the socket we rejected socket number and are similarly unhappy with meyer s socket code the word socket should not be used as part of the field name and we solicit suggestions iii environment we assume that the typical host will have a time sharing operating system in which the cpu is shared by processes processes we envision that each process is tagged with a user number there may be more than one process with the same user number and if so they should all be cooperating with respect to using the network we envision that each process contains a set of ports which are unique to the process these ports are used for input to or output from the process from or to files devices or other processes we also envision that each process has an event channel over which it can receive very short messages several bits we will use this mechanism to notify a process that some action external to the process has occurred to engage in network activity a process attaches a local socket to one of its ports sockets are identified by user number host and aen and a socket is local to a process if their user numbers match and they are in the same host a process need only specify an aen when it is referring to a local socket each port has a status which is modified by system calls and by concurrent events outside the process whenever the status of a port is changed the process is sent an event over its event channel which specifies which port s status has changed the process may then look at a port s status these assumptions are used descriptive material which follows however these assumptions are not imposed by the network protocol and the implementation suggested by section iv is in no way binding postel crocker page rfc a possible protocol plateau april we wish to make very clear that this material is offered only to provide clues as to what the implementation difficulties might be and not to impose any particular discipline for example we treat s which arrive for unattached local sockets as valid and queue them if desired an ncp may reject them as meyer suggests or it might hold them for awhile and reject them if they re not soon satisfied the offered protocol supports all these options another local option is the one mentioned before of attaching multiple ports to a socket we have shown one one correspondence but this may be ignored similarly the system calls are merely suggestive system calls these are typical system calls which a user process might execute we show these only for completeness each site will undoubtedly implement whatever equivalent set is convenient we use the notation syscall arg arg val where syscall is the system call arg etc are the parameters supplied with the call and val etc are any values returned by the system call init p aen fs bsiz c p specifies a port of the process aen specifies a local socket the user number of this process and host number of this host are implicit fs specifies a socket with any user number in any host with any aen bsiz specified the amount of storage in bits the user wants to devote to buffering messages c the condition code returned init attempts to attach the local socket specified by aen to the port p and to initiate a connection with socket fs possible returned values of c are postel crocker page rfc a possible protocol plateau april c ok the init was legal and the socket fs is being contacted when the connection is established or when fs refuses the process will receive an event c busy the local socket was in use by a port on this or some other process with the same user number no action was taken c homosex the aen and fs were either both send or both receive sockets c nohost the host designated within fs isn t known c bufbig bsiz is too large listen p aen bsize c p specifies a port of the process aen specifies a local socket bsiz specified a buffer size c the returned legality code codes for c are c ok c busy c bufbig the local socket specifies by aen is attached to p if there is a waiting call it is processed otherwise no action is taken when a call comes in a connection will be established and the process notified via an event close p p specifies a port of the process any activity is stopped and the port becomes free for other use transmit p m l l c p specifies port with an open connection m the text to be transmitted l specifies the length of the text l the length actually transmitted c the error code postel crocker page rfc a possible protocol plateau april transmission between the processes on either side of the port takes place codes for c are c ok or c not open if no connection is currently open and otherwise uninhibited status p c the status of port p is returned as c iv the ncp we view the ncp as having five component programs three associative tables some queues and buffers and a link assignment table each site will of course vary this design to meet its needs so our design is only illustrative the component programs the input handler this is an interrupt driven input routine it initiates imp to host transmission into a resident buffer and wakes up the input interpreter when transmission is complete the output handler this is an interrupt driven output routine it initiates host to imp transmission out of a resident buffer and wakes up the output scheduler when transmission is complete the input interpreter this program decides whether the input is a regular message intended for a user a control message an imp to host message or an error for each class of message this program takes the appropriate action the output scheduler three classes of message are sent to the imp a host to imp messages b control messages c regular messages postel crocker page rfc a possible protocol plateau april we believe that a priority should be imposed among these classes the priority we suggest is the ordering above the output scheduler selects the highest priority message and gives it to the output handler the system call interpreter this program interprets requests from the user the two interesting components are the input interpreter and the system call interpreter these are similar in that the input interpreter services foreign requests and the system call interpreter services local requests associative tables we envision that the bulk of the ncp s data base is in three associative tables by associative we mean that there is some lookup routine which is presented with a key and either returns successfully with a pointer to the corresponding entry or fails if no entry corresponds to the key the rendezvous table requests for connection and other attributes of a connection are held in this table this table is accessed by local socket but other tables have pointers to existing entries the components of an entry are a local socket key b foreign socket c link d queue of callers e text queue f connection state g flow state h pointer to attached port an entry is created when a user executes either an init or a listen system call or when a is received some fields are unused until the connection is established e g the foreign socket is not known until a arrives if the user did a listen postel crocker page rfc a possible protocol plateau april the input link table the input interpreter uses the foreign host and link as a key to get a pointer to the entry in the rendezvous table for the connection using the incoming link the output link table in order to interpret rfnm s the input interpreter needs a table in the same form as the input link table but using outgoing links link assignment table this is a very simple structure which keeps track of which links are in use for each host one word per host probably suffices the following diagram is our conception of the network control program boxes represent tables and buffers boxes with angled corners and a double bottom represent queues and jagged boxes represent component programs the arrows represent data paths the abbreviated names have the following meanings ilt input link table olt output link table lat link assignment table rt rendezvous table hiq host to imp queue occq output control command queue ormq output regular message queue ihbuf buffer filled by the input handler from the imp and emptied by the input interpreter ohbuf buffer of outgoing messages filled from the queues by the output scheduler and emptied by the output handler postel crocker page rfc a possible protocol plateau april i m p v input output handler handler v oh im buf buf v output input scheduler hiq interpreter v o o c r v v v c m q v q ilt lat olt r t v system call interpreter system calls postel crocker page rfc a possible protocol plateau april this rfc was put into machine readable form for entry into the online rfc archives by donald and jill eastlake editor s note the original hand drawn diagram represented queues by cylinders and component programs by squishy ameoba like things postel crocker page 